[{"content":"前言 今天看到 WordPress 6 发布了,回想多年以前在使用 WordPress 的时候,一顿 yum 命令安装 nginx, php, mysql, php-fpm , 然后再配置 nginx, 经过一阵子配置, WordPress 就运行成功了, 如今在云原生时代, 可以用 k8s , docker , Podman 等工具来安装这些系统了, 今天就使用 Podman 安装 WordPress , 人生苦短, 我用 podman !\n认知准备  这次是安装一个业务系统(WordPress) , 所以不象一些 hello world 的文章, 更多要关注底层的一些东西 网络(network): WordPress 要和 mysql 连接, 所以需要网络支持 数据卷(volume): mysql 数据要保存, WordPress 的文章数据保存在数据库中,但是插件/主题,上传图片等都是保存在文件系统中, 文件系统的内容要保存下来, 就要使用到数据卷功能. 使用 Podman 4.1.0 版本  安装过程 网络 使用 podman network ls , 可以查看 Podman 的网络列表, 默认会有一个 Podman 的网络, 这里我们会创建一个新的网络叫做 wp-net , 使用如下命令:\n1 2 3  podman network create wp-net # 使用 podman network inspect 命令查看网络信息 podman network inspect wp-net   输出内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  { \u0026#34;name\u0026#34;: \u0026#34;wp-net\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;a47201502d7f6450e7fda6c1ce7e449418350cb2b668feca2cf7d5048cb336cc\u0026#34;, \u0026#34;driver\u0026#34;: \u0026#34;bridge\u0026#34;, \u0026#34;network_interface\u0026#34;: \u0026#34;cni-podman2\u0026#34;, \u0026#34;created\u0026#34;: \u0026#34;2022-06-02T10:45:05.864113967+08:00\u0026#34;, \u0026#34;subnets\u0026#34;: [ { \u0026#34;subnet\u0026#34;: \u0026#34;10.89.1.0/24\u0026#34;, \u0026#34;gateway\u0026#34;: \u0026#34;10.89.1.1\u0026#34; } ], \u0026#34;ipv6_enabled\u0026#34;: false, \u0026#34;internal\u0026#34;: false, \u0026#34;dns_enabled\u0026#34;: true, \u0026#34;ipam_options\u0026#34;: { \u0026#34;driver\u0026#34;: \u0026#34;host-local\u0026#34; } } ]   MySQL 创建好 wp-net, 后,我们创建 mysql 容器,并且把它加入到 wp-net 中 , 命令如下:\n1 2 3 4 5 6 7 8  # 创建存放 mysql 数据的临时目录 mkdir -p /tmp/mysql-data podman run --name mysql \\  --net wp-net \\  -e MYSQL_ROOT_PASSWORD=my-password \\  -v /tmp/mysql-data:/var/lib/mysql \\  -d docker.io/library/mysql:8   说明:\n \u0026ndash;net wp-net 参数就是把创建的 mysql 容器加入到 wp-net 这个网络中, 并且使用 \u0026ndash;name mysql , 这样网络中的其他容器就能使用 mysql 这个网络名,解析出 mysql 容器的 ip 了, 也可以使用 \u0026ndash;hostname 参数来指定网络主机名. -e MYSQL_ROOT_PASSWORD 设定 mysql root 密码 -v /tmp/mysql-data:/var/lib/mysql 将主机的 /tmp/mysql-data 目录映射到容器中 /var/lib/mysq 目录, 这就是数据卷(volume) 的功能,这样数据就可以保存到主机中,这里在 tmp 目录创建方便临时测试,volume 功能也可以使用 podman volume 命令创建命名的数据卷. 这里没有使用 -p 3306:3306 类似的端口映射参数,因为我们 host 不需要去访问 mysql ,容器网络中访问不需要映射端口.  创建好 mysql 容器后可以使用以下命令做些检查\n1 2 3 4 5  # 使用 ps 命令可以查看运行中的容器, 这里应该可以看到 mysql 容器 podman ps # 使用 exec 命令可以运行容器中的程序, 这里运行 bash ,就可以进入容器的 bash 中运行其他命令了. podman exec -it mysql bash   Wordpress mysql 容器运行后,就可以去创建 WordPress 了, WordPress 镜像的详细信息可以去 docker hub 去看: https://hub.docker.com/_/wordpress\nWordPress 中会用到的配置主要是: 数据连接信息, 可变的内容主要是 wp-conent 目录下的主题/插件,上传文件信息, 如果你不去使用环境变量配置数据库信息, 那么动态配置的 wp-config.php 也是可变的.\n运行 WordPress 的容器命令如下:\n1 2 3 4 5  # 我们先用最简单的命令运行 wordpress 容器, 尽快见一下久违的 wordpress podman run --name wordpress \\  --net wp-net \\  -p 8080:80 \\  -d docker.io/library/wordpress:6   创建好后, 我们就可以访问 http://localhost:8080/ 我见证 WordPress 的安装了, 因为没有配置数据库信息,所以 WordPress 进入了数据库配置页面: 这里 database host 只需要填写 mysql 即可, 容器中会自动解析 mysql 容器的 ip.\nWordPress 不会主动去创建数据库,所以我们需要进入 mysql 容器去创建一个 wordpress 的数据库. 命令如下:\n1 2 3 4 5 6 7 8 9  # 进入容器 podman exec -it mysql bash # 使用 root 密码 my-password 登陆数据库 mysql -u root -p # 创建数据库 create database `wordpress`; #完成后就可以退出了,继续下一步安装 wordpress   到此, WordPress 6 测试安装完成了.\n上面创建的 WordPress 容器没有使用数据卷功能, 那么如果你上传了一些图片信息,安装了一些插件,这些内容都保存在容器里面,如果有一天容器被删除了,也就没有了,我们现在重新创建这个 wordpress 容器,并且使用数据卷功能,将可变的目录映射到 host 中.\n先删除现有的 wordpress 容器\n1  podman rm -f wordpress   1 2 3 4 5 6 7 8 9 10 11 12 13  # 创建用于测试的临时目录 mkdir -p /tmp/wordpress/wp-content podman run --name wordpress \\  --net wp-net \\  -p 8080:80 \\  -v /tmp/wordpress/wp-content:/var/www/html/wp-content/ \\  -e WORDPRESS_DB_HOST=mysql \\  -e WORDPRESS_DB_USER=root \\  -e WORDPRESS_DB_PASSWORD=my-password \\  -e WORDPRESS_DB_NAME=wordpress \\  -e WORDPRESS_TABLE_PREFIX=wp_ \\  -d docker.io/library/wordpress:6   现在我们去看 /tmp/wordpress/wp-content 目录, 可以看到已经有相关目录出现在其中了,这样容器即使被销毁,这些数据也是保存在 host 中了. 总结 5-10 分钟就将 WordPress 安装好了, 基本不需要去做系统配置(nginx,php,mysql). 这正式容器技术带来的便利.\n文章中使用了 Podman 的基本功能, 有以下方面需要注意\n Podman 容器默认不会跟随系统启动, 需要配合 systemd 服务启动, 具体可以查看 https://docs.podman.io/en/latest/markdown/podman-generate-systemd.1.html 数据卷(volume) 更多功能使用 podman volume \u0026ndash;help 命令查看, 可以配置 nfs 的 volume 等. 应用和数据库组合的容器组可以使用 podman-comose 实现, 也可以使用 Podman 的 pod 功能实现,具体查看官方文档.  ","date":"2022-06-02T12:37:58+08:00","image":"https://liangdi.me/p/run-wordpress-6-arturo-with-podman/assets/podman-wordpress_hu26d914e965d24c838e4aef4a305c3a00_65209_120x120_fill_box_smart1_3.png","permalink":"https://liangdi.me/p/run-wordpress-6-arturo-with-podman/","title":"使用 Podman 运行 WordPress 6 Arturo"},{"content":"前言 看到标题,是不是觉得我疯了,爬虫,这个时间点应该还轮不到 rust 吧!\n确实,现在成熟的爬虫技术基本使用 python, java 等,那么这篇文章的用意是什么呢? 我先来交代一下背景, 2017 年,我挖了一个坑: https://zhuanlan.zhihu.com/p/24900305\n这个项目后来商用了,所以就不方便继续更新, 到了现在 2022 年了, 各种技术已经迭代了好多次, 那么,我也要重新思考一下一套新的爬虫架构了,这套架构基于云原生,容器化,结合不同语言取长补短,相互配合,简单概括如下:\n 爬虫节点容器运行,语言无关,所以会支持 python ,java 等各语言开发的爬虫 统一的 DAG 任务分发调度节点 统一的数据集接口  其中一点是爬虫语言无关,所以会设计统一的输入输出接口,让各语言编写的程序都能在容器中执行, python, java, golang 的爬虫生态都很不错了,文章也很多, rust 这方面比较少,所以这里就写一篇 rust 的文章.\n爬虫底层关注的技术点  http 库 html 解析 json 解析 WebDriver 集成  http 库 作为爬虫的 http 库, 只要支持 http 协议基本就 ok, 主要是设置 header, 设置 cookies, 设置代理等等.\nrust 的 http 库列表 https://lib.rs/web-programming/http-client\n这里使用 reqwest 做个简单的示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  usereqwest;usehttp::{HeaderMap,HeaderValue,header::{COOKIE,USER_AGENT}};#[tokio::main]asyncfn main()-\u0026gt; Result\u0026lt;(),reqwest::Error\u0026gt;{// HTML leturl=\u0026#34;https://ssr1.scrape.center/\u0026#34;;letresp=reqwest::get(url).await?;println!(\u0026#34;Response: {:?} {}\u0026#34;,resp.version(),resp.status());println!(\u0026#34;Headers: {:#?}\\n\u0026#34;,resp.headers());//println!(\u0026#34;Body:{:#?}\u0026#34;,resp.text().await?); // JSON leturl=\u0026#34;https://spa1.scrape.center/api/movie/?limit=10\u0026amp;offset=0\u0026#34;;letresp=reqwest::get(url).await?;letjson_body:serde_json::Value=resp.json().await?;println!(\u0026#34;Json:{:#?}\u0026#34;,json_body);// POST let_resp=reqwest::Client::new().post(url).form(\u0026amp;[(\u0026#34;name\u0026#34;,\u0026#34;value\u0026#34;)]).send().await;// Header let_resp=reqwest::Client::new().post(url).header(\u0026#34;Auth\u0026#34;,\u0026#34;xxx\u0026#34;).send().await;// UserAgent Cookies letclient=reqwest::Client::builder().cookie_store(true).build().unwrap();letmutheaders=HeaderMap::new();headers.insert(COOKIE,HeaderValue::from_str(\u0026#34;key=value\u0026#34;).unwrap());headers.insert(USER_AGENT,HeaderValue::from_str(\u0026#34;my user-agent\u0026#34;).unwrap());let_reps=client.get(url).headers(headers).send().await?;Ok(())}  Cargo.toml\n1 2 3 4 5  [dependencies] http = \u0026#34;0.2.7\u0026#34; reqwest = {version = \u0026#34;0.11.10\u0026#34;,features = [\u0026#34;json\u0026#34;,\u0026#34;cookies\u0026#34;] } serde_json = \u0026#34;1.0.81\u0026#34; tokio = {version =\u0026#34;1.18.2\u0026#34;,features = [\u0026#34;full\u0026#34;] }   html/json 解析 采集到 html 和 json 数据后,需要解析出有用的数据, html 内容主要用 css 选择器筛选, json 可以转 map 或者使用 jsonpath 筛选, 这里使用 scraper 和 jsonpath 这两个库做个简单示例.\nCargo\n1 2  cargo add scraper cargo add jsonpath   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  usereqwest;usescraper::{Html,Selector};#[tokio::main]asyncfn main()-\u0026gt; Result\u0026lt;(),reqwest::Error\u0026gt;{// HTML leturl=\u0026#34;https://ssr1.scrape.center/\u0026#34;;letresp=reqwest::get(url).await?;//println!(\u0026#34;Body:{:#?}\u0026#34;,resp.text().await?); letbody=resp.text().await?;letdoc=Html::parse_fragment(\u0026amp;body);letselector=Selector::parse(\u0026#34;.m-b-sm\u0026#34;).unwrap();forelindoc.select(\u0026amp;selector){println!(\u0026#34;title:{}\u0026#34;,el.inner_html());}// JSON leturl=\u0026#34;https://spa1.scrape.center/api/movie/?limit=10\u0026amp;offset=0\u0026#34;;letresp=reqwest::get(url).await?;letjson_body:serde_json::Value=resp.json().await?;//println!(\u0026#34;Json:{:#?}\u0026#34;,json_body); letjson_sel=jsonpath::Selector::new(\u0026#34;$.results.*.name\u0026#34;).unwrap();forjson_elinjson_sel.find(\u0026amp;json_body){println!(\u0026#34;json title:{}\u0026#34;,json_el.as_str().unwrap());}Ok(())}  运行结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  title:霸王别姬 - Farewell My Concubine title:这个杀手不太冷 - Léon title:肖申克的救赎 - The Shawshank Redemption title:泰坦尼克号 - Titanic title:罗马假日 - Roman Holiday title:唐伯虎点秋香 - Flirting Scholar title:乱世佳人 - Gone with the Wind title:喜剧之王 - The King of Comedy title:楚门的世界 - The Truman Show title:狮子王 - The Lion King json title:霸王别姬 json title:这个杀手不太冷 json title:肖申克的救赎 json title:泰坦尼克号 json title:罗马假日 json title:唐伯虎点秋香 json title:乱世佳人 json title:喜剧之王 json title:楚门的世界 json title:狮子王   WebDriver 集成 一些网站由于反爬,构建 http 请求会遇到一些额外问题,那么使用 webdriver 将会是另外一种爬虫解决方案, 这里使用 thirtyfour 这个库\nCargo\n1 2  cargo add thirtyfour cargo add tokio   先运行 webdriver, 我这里使用 chromedriver , 默认监听 9515 端口\n示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  usethirtyfour::{prelude::*,error::WebDriverError};usetokio;#[tokio::main]asyncfn main()-\u0026gt; Result\u0026lt;(),WebDriverError\u0026gt;{leturl=\u0026#34;https://spa1.scrape.center/\u0026#34;;letcaps=DesiredCapabilities::chrome();letdriver=WebDriver::new(\u0026#34;http://localhost:9515\u0026#34;,caps).await?;driver.get(url).await?;// 等待我们要的元素 letcheck=driver.query(By::Css(\u0026#34;.m-b-sm\u0026#34;)).first().await?;check.wait_until().displayed().await?;letels=driver.find_elements(By::Css(\u0026#34;.m-b-sm\u0026#34;)).await?;forelinels{println!(\u0026#34;el:{}\u0026#34;,el.inner_html().await?.as_str());}driver.quit().await?;Ok(())}  运行结果\n1 2 3 4 5 6 7 8 9 10  el:霸王别姬 - Farewell My Concubine el:这个杀手不太冷 - Léon el:肖申克的救赎 - The Shawshank Redemption el:泰坦尼克号 - Titanic el:罗马假日 - Roman Holiday el:唐伯虎点秋香 - Flirting Scholar el:乱世佳人 - Gone with the Wind el:喜剧之王 - The King of Comedy el:楚门的世界 - The Truman Show el:狮子王 - The Lion King   简单总结  支持爬虫操作的基础库基本都是涵盖的 相关的示例代码或者教程还是缺少 这次验证下来,还是可以满足我新系统设计的需求的,可以使用 rust 开发爬虫节点  ","date":"2022-05-06T00:38:25+08:00","image":"https://liangdi.me/p/simple-rust-crawler-technology-research/assets/rust-crawler_hu9902f331a47214e88fbddd7e7a10ce30_25175_120x120_fill_box_smart1_3.png","permalink":"https://liangdi.me/p/simple-rust-crawler-technology-research/","title":"一次简单的 rust 爬虫开发技术调研"},{"content":"前言 大家好,我是 Liangdi, podman 4.x 版本已经发布了, 我也从 docker 开始向 podman 迁移, 所以是合适的时候写点 podman 的文章了.\npodman 是什么 官方网站: podman.io\n官方自己的介绍: https://podman.io/whatis.html\n名称 podman ,官方说明是 Pod Manager , 所以它不仅可以管理 OCI 容器,还可以管理 pod , 这也是和 docker 的最大差别吧.\n和 kubernetes 的区别 kubernetes(k8s) 是目前最流行的容器编排工具, 集群管理工具, 生态很完善, 也很\u0026quot;重\u0026quot;, pod 的概念就来自 k8s , 虽然 podman 也是管理 pod, 但是远远不及 k8s 的编排功能, 同时 podman 也没有集群管理功能,如果需要管理集群, 需要第三方工具完成.\n所以 podman 定位也不是编排和集群管理工具, 紧紧是一个 pod 和容器的管理工具. 所以不是一个级别的东西, 这里不做太多的比较.\n和 docker 的区别 如果仅仅从 docker 和 podman 两个命令提供的功能来讲,它们功能交集很大, podman 官方甚至推荐 alias docker=podman 来过渡.\n docker 文档更齐全, podman 可以借用一下 docker 的文档 docker 生态更加完善, podman 一时半会赶不上,但是如果你只是去跑容器, 那这是一样的 docker 有 docker-compose, podman 早期没有对应工具,后面也出了 podman-compose, 但是这个功能是否必须? 值得考虑,因为 podman 支持 pod 管理. docker 有 machine , 让 windows 和 mac 支持 linux 容器, podman 也支持,而且已经比较完善. docker 有 docker-desktop , podman-desktop 目前还比较简单. docker 支持 rest api , podman 也支持 rest api, 这使得开发生态工具会比较简单. docker 有 swarm 支持集群部署, podman 没有对应工具, 不过支持 remote , 调用远程机器上的 podman service 执行对应的功能 , 这样能满足很多轻量化的场景. k8s 之前支持使用 docker-shim 和 docker 集成, 不过新版本也放弃这一层, 直接通过 CRI 调用 contained , podman 也不支持 CRI. 并且也没有什么计划. docker 商业/开源并行, podman 只有开源版本, 目前没有哪家公司提供商业支持(不清楚 redhat 有没有对应的服务,可能集成在订阅里面了).  为什么选 podman 上面讲了不少 docker 比 podman 有优势的方面, 这里开始讲 podman 的另外的东西, 这也是我选择 podman 主要原因.\n先罗列一下 podman 适合的场景\n 没有很强的集群管理需求(或者说,已经有 overlay network 方案, podman 也是适用的) 仅仅为了容器化一些应用 团队内部轻量级使用,比如 ci/cd , 开发,测试环境等. 喜欢命令行或者脚本运维 感兴趣 podman 的生态建设(坑)  那么 podman 比 docker 好的方面有哪些呢?\n 更加 rootless , 尽管 docker 也可以 rootless, 但是 podman 设计之初就开始支持 没有 daemon , 这使得 podman 在结合 namespace 和 cgroup 一起使用会更加灵活 pod , 和 k8s 基本一样的 pod , 一样支持 infra 容器. 这使得一些简单的容器编排 工作, podman 也可以简单实现. systemd service 集成, 由于没有 deamon , podman 通过 generate 子命令, 可以生成 systemd service 配置, 来管理容器和 pod 的作为服务启动. k8s 关联, podman 可以生成 kubectl 的 yaml 配置文件, 也通过 podman play kube 来运行 k8s 的配置, 也可以作为 k8s 的一个过渡吧, 而且 podman 也没有去实现 CRI 的计划, 这应该也是官方的态度, 不会参和到 k8s 生态中, 保持自己的轻量化工具的定位吧. remote , podman 通过 ssh 隧道或者 tcp 端口, 可以连接到远程机器上的 podman service, 从而实现远程机器上的容器和 pod 管理.  所以 podman 提供了一些轻量化而又灵活的功能特性,满足容器化,以及小批量服务器的场景.\n最后聊聊 podman 所在的 https://github.com/containers 组织 查看这个组织的仓库可以看到,他们真的是在做容器工具, 而且写了很多轮子, 包括 buildah 和 skopeo 这两个工具,与 podman 一起被称为下一代容器工具.\nrunc 是一个有名的 low-level OCI rumtime, 他们就开发了一个 crun . podman 早期版本使用 runc, 最新的版本已经使用 crun 了.\n众所周知, golang 是容器生态的主要语言, podman 也是 go 写的,但是在 podman 4 的版本中, podman 增加了非 CNI 的网络栈支持, 这几个工具是 netavark 和 aardvark-dns, 这两个工具是 rust 写的, 而且还有 youki 这个 rust 写的 low-level OCI runtime, 不知道将来某一天 podman 会不会默认使用 youki , 还有好几个 rust 写的容器技术相关的应用和库, 这是要与 golang 分天下的节奏.\n如果你也对 podman 以及其生态感兴趣, 关注我吧, 我会给你带来 podman 最新的动态以及实践方案.\n我的技术 Blog:https://liangdi.me\n","date":"2022-04-27T16:30:35+08:00","image":"https://liangdi.me/p/what-is-podman-and-different-from-kubernetes-and-docker/assets/podman-vs-docker_hub3205ed3c893c1f053112545244d1e4e_65326_120x120_fill_q75_box_smart1.jpg","permalink":"https://liangdi.me/p/what-is-podman-and-different-from-kubernetes-and-docker/","title":"选择 podman 的理由, 以及它和 Kubernetes , Docker 的区别"},{"content":"概述 使用 rust 也挺长时间了,但是一直是内部小打小闹,没有往客户那边推, 这次和客户商量好,拿一个很小的 java spring boot 项目开刀.\n这个项目小到 tiny 级别, 主要功能是: 请求一个服务, 对数据进行业务逻辑处理后, 使用 freemarker 渲染呈现给终端用户, rest api 也就 10 多个.\n迁移准备 首先,业务逻辑使用 rust 实现,肯定是没有大问题, 关键在于一些中间件和第三方库是否有替代,这样可以让运维或者交付更加平滑一点, 由于项目比较简单,第三方库也很通用,基本在 rust 这边也有对等的选择,所以本次迁移也将会简单很多.\n迁移说明 库和中间件迁移    库/中间件 Rust 版本 Java 版本 备注     Web Framework actix-web 4 Spring Boot 2.6.x    http cleint reqwest jdk 11 HttpClient    json serde_json gson    template tera freemarker    logging log4rs spring boot logging    assets embedded rust-embed spring boot static    配置 dotenv spring boot 项目小, 配置需求不高, dotenv 够用    有没有坑?  由于项目实在不复杂, 过程中也没有遇到特别的问题, rust 的库也能正常工作, 从代码的角度很多时候比 java 简洁, 当然集成没有 spring boot 那么简单, 比如配置的自动读取赋值, 模板需要手动集成等等. spring boot 的 rest request 配置, 对应在 actix-web 中也是很简单,使用 #[get], #[post] 等宏实现, 请求内容的解构也一样完善, 迁移过程中没有遇到什么问题. 模板方面, tera 是 Jinja2/Django like 的所以,使用起来也没有什么障碍. 战胜 rust 编译器后,程序运行,完成测试没有遇到什么 bug !  迁移后的变化 程序尺寸  spring boot jar 大小 20MB, 即使是 spring-native 打包也要 60 多 mb, 并且 spring-native 打包的程序没法正常运行,因为 spring-native 还没有 GA ,所以也没有去深究. rust 的程序使用 x86_64-unknown-linux-musl target release 静态编译打包(默认配置,无其他优化), 程序 strip 后是 9.3MB , 相比 jar 也小了一半, 还没考虑 jdk. 容器化, 这点 rust 的优势就体现出来了, 使用 FROM scratch 打包出来的镜像大小是 9.75MB , 相比 spring boot 项目, 基本的 openjdk:17-alpine 就有 320 多 MB 加上项目程序,也要 340 多 MB 了.  性能  肉眼可见的启动块了, 模板渲染也快了 程序瓶颈在于远程的服务,所以当前程序性能测试并不一定可靠,所以并没有去做特别的测试 后续迁移更多项目后,再进行一次性能测试比较  思考  如果项目不复杂, java 迁移到 rust 还是不算复杂的. 容器化的收益是不小的,不管是启动速度还是镜像大小. 后面考虑将微服务化的 java 项目选择合适的项目再进行 rust 迁移.  ","date":"2022-04-26T11:06:35+08:00","image":"https://liangdi.me/p/a-tiny-app-migrate-from-java-to-rust/assets/java-rust_hu1a0eedb3cb55262de642044ece3234a1_193060_120x120_fill_box_smart1_3.png","permalink":"https://liangdi.me/p/a-tiny-app-migrate-from-java-to-rust/","title":"记录一次 java 小项目的 rust 迁移过程"},{"content":"何为云原生  云原生一词可谓是大红大紫, 老板见面不说一下都觉得落伍了,技术人员更是要与时俱进,学习这一系列的新技术\n 先看看 CNCF 对云原生的最新定义,注意云原生的定义一直是演进的,随着新技术,新架构的发展,定义也会变化.\n 云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式API。\n  这些技术能够构建容错性好、易于管理和便于观察的松耦合系统。结合可靠的自动化手段，云原生技术使工程师能够轻松地对系统作出频繁和可预测的重大变更。\n 以上这两段话来自 CNCF 的云原生定义.\n简单的说就是用各种技术实现了大多数人梦寐以求的理想系统方案!\n但是,如果一个传统技术栈的团队,要向云原生迁移,代价会是多大呢? 这是个值得思考的问题.\nCNCF 有两个子站点 https://glossary.cncf.io/ 和 https://landscape.cncf.io/\n这两个站点可以大致了解云原生涉及到新概念以及生态图谱, 如此多的概念和繁杂的生态,对于传统技术团队来说将会带来额外的心智负担以及新的挑战.\n渐进式云原生 因此针对我们小团队以及小部门,我提出了渐进式云原生 和 轻量化云原生 的概念,以便云原生落地.\n渐进式云原生 是指自下往上,分阶段完成云原生迁移和落地. 这里大概会包含 容器化, 微服务化 , DevOps ,CI/DI 等方面向云端迁移, 而且不强调顺序, 实际的顺序大多数根团队的技术栈相关.\n所以这系列应该不会出现一来就叫你部署一套 k8s 集群, 可能到最后也不会,而是取决于你自己的选择.\n这一系列就是一次渐进式云原生的实践,废话一大推,我们进入正题\n使用 podman 容器化你的应用 第一篇是使用 podman 容器化你的应用 , 我认为容器化是迈向云原生过程中最简单的部分, 技术也成熟,风险不大. 这里为什么选择 podman ,详谈的话,需要再开一篇文章.\n实践目标 将一个传统的项目 CentOS -\u0026gt; Nginx -\u0026gt; (Spring Boot, MySQL, Redis) 容器化\n原项目是一个不算复杂的 Spring Boot 应用, 由于 Java 没法热更新, 所以使用 Nginx 反向代理了两套 Spring Boot 应用(两套应用可以同时运行也可以只运行一套), 关键时刻可实现用户无感知更新.\n两套 Spring Boot 应用监听不同端口, 使用 Systemd 作为系统服务配置, 上传新 jar 包后, 重启一个项目后, 再重启另外一个项目, 可以通过简单脚本实现.\n前端静态页面\n拓扑图如下: 实践过程 系统和 podman 的版本选择 原先部署在 CentOS 8 上, 这次容器化对 HOST 系统就没有特别的要求了, 所以选择了 Fedora Server, 三个原因: 一, 本人工作电脑使用 Fedora . 二, 容器技术依赖于 Linux 内核的 cgroup 和 namespace 技术,新内核会比老内核有优势, 虽然 Fedora 内核很新, 但是我相信 Linux 内核的稳定性. 三, CentOS 已经不再维护.\nPodman 我选择了最新的 4.0.x, 它和 3.x 版本不兼容功能, 但是使用上不会有差别, 主要是网络功能默认使用了 netavark 和 aardvark-dns ,没有使用 cni, 这两个工具是用 rust 编写的, 这也是我去尝试的主要原因之一\n容器使用选择 rootfull 还是 rootless , 我这里选择 root 运行, rootless 其实问题也不大,我测试除了没法 ping, 80/443端口等问题外, 还有一个不算特别大的问题就是, 容器创建好后无法再加入网络,需要创建的时候指定网络, root 情况下没问题.\n禁用 selinux  安装 podman fedora 中安装 podman 很简单\n1 2  sudo dnf copr enable rhcontainerbot/podman4 sudo dnf install podman   如果是安装 3.x 的版本, 还需要额外安装 podman-plugins 包,以实现 cni 网络的 dns 服务功能\n1 2  sudo dnf install podman sudo dnf install podman-plugins   在使用上版本 4 和版本 3 没有直接区别\n新的拓扑架构 还没有完全想好 nginx 这个前端代理以及前端静态页面是否要容器化,所以这里先保留之前的部署方案,拓扑图如下: 创建容器网络和基础容器 根据新的拓扑设计, Spring Boot 应用, MySQL , Redis 将会是以独立容器存在,所以需要创建一个网络将他们链接.\n1 2 3 4 5 6  # 创建名为 prod 的容器网络 podman network create prod # 查看网络 podman network ls # 之后创建或者运行容器的时候使用 --net prod 即可将容器加入到这个网络中   redis 容器\n使用以下命令创建 redis 容器\n1  podman run -d --name redis --net prod redis   podman 支持多镜像服务器 , 所以如果不指定镜像服务器, 会让你选择, 一般选择 dokcer.io 的即可\n注意: 上面使用 \u0026ndash;net prod 将 redis 容器加入到网络中, 同时指定了名字 redis , 这样网络中的主机名会是 redis , 也可以使用 \u0026ndash;hostname 参数\n注意2: 上面的命令没有使用 -p 6379:6379 将 redis 端口暴露出来,因为我们的 Spring Boot 应用也会加入到 prod 网络中,内网是可以访问的,所以不需要暴露出来.\n可以使用以下命令测试 redis 容器\n1 2 3 4  podman exec -it redis redis-cli PING # 正常返回 PONG # 也可以进入容器 bash 测试 podman exec -it redis bash   mysql 容器\n1 2 3 4 5  podman run \\  -e MYSQL_ROOT_PASSWORD=12345678 \\  --net prod \\  -v /opt/deploy/mysql/data:/var/lib/mysql \\  --name mysql -d mysql:8   -e MYSQL_ROOT_PASSWORD=12345678 指定了容器中 mysql root 用户的密码\n-v /opt/deploy/mysql/data:/var/lib/mysql 将 host 机器 /opt/\u0026hellip;./data 目录挂载到容器中 /var/lib/mysql 中, 这样 mysql 数据才能正常保存,如果缺少这个, 容器重启后, 数据将会被重置.\n更多配置查看 https://hub.docker.com/_/mysql\n创建 Spring Boot 容器 应用容器比较特殊,因为是内部应用, 也没法将应用发布到公共镜像上, 正常的流程是将应用打包,发布到私有镜像服务器中,再在 podman 中使用, 这里先跳过这一步,不然内容太多了!!!\n我这里创建了一个公共镜像 https://github.com/Liangdi/spring-boot-launcher\n这个镜像主要就是 jdk 环境,可以通过配置端口和 jar 名称,运行指定的 Spring Boot 项目\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  # 创建端口为 9090 的 Spring Boot 应用 PORT=9090 podman run -d --name sprin-boot-app-$PORT \\ -v /opt/deploy/app/:/deploy \\ -e APP_PORT=$PORT \\ --net prod \\ -p $PORT:$PORT \\ docker.io/liangdi/spring-boot-launcher # 创建端口为 9091 的 Spring Boot 应用 PORT=9091 podman run -d --name sprin-boot-app-$PORT \\ -v /opt/deploy/app/:/deploy \\ -e APP_PORT=$PORT \\ --net prod \\ -p $PORT:$PORT \\ docker.io/liangdi/spring-boot-launcher   Spring Boot 应用容器化后,只需要将原先 mysql , redis 的链接配置修改一下即可, 原先是使用 127.0.0.1, 容器化后,改为容器主机名 mysql 和 redis 即可.\nNginx 反向代理和前端静态文件方面,没有去改动.\n到此, 此次 Spring Boot 应用基本容器化完成, 后续就是要将应用微服务化了. 伴随着渐进式云原生,可能在运维,测试,客户交付方面也会有所改变.\n创建 systemd 服务 使用 podman generate systemd 创建 sytemd service, 具体看文档 https://docs.podman.io/en/latest/markdown/podman-generate-systemd.1.html , 这里不再说明.\n容器化总结  基本的容器化,程序开发上不需要有改变, 只是简单修改 prod 的配置文件 运维人员工作流程基本没变 podman 基本兼容 docker 命令,所以有 docker 经验将很容易上手. 静态页面需不需要容器化,值的思考,如果是大流量应用, 静态页面肯定是 CDN , 如果是小应用, 那么多开一个容器多起一个静态服务器是否又是浪费? 我这次没有将静态页面容器化. 后续有新想法后再迭代 podman 中还有 pod 管理功能,这也是我选择 podman 的原因之一,这方面将会在下次容器有化中使用. 这次交付产物使用 -v 路径的方式告知容器,后续可以使用命名 volume 替代.  ","date":"2022-04-23T16:59:14+08:00","permalink":"https://liangdi.me/p/progressive-cloud-native-with-podman/","title":"渐进式云原生实践: 使用 podman 容器化你的应用"}]