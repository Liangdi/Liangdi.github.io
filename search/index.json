[{"content":"前言 大家好,我是 Liangdi, podman 4.x 版本已经发布了, 我也从 docker 开始向 podman 迁移, 所以是合适的时候写点 podman 的文章了.\npodman 是什么 官方网站: podman.io\n官方自己的介绍: https://podman.io/whatis.html\n名称 podman ,官方说明是 Pod Manager , 所以它不仅可以管理 OCI 容器,还可以管理 pod , 这也是和 docker 的最大差别吧.\n和 kubernetes 的区别 kubernetes(k8s) 是目前最流行的容器编排工具, 集群管理工具, 生态很完善, 也很\u0026quot;重\u0026quot;, pod 的概念就来自 k8s , 虽然 podman 也是管理 pod, 但是远远不及 k8s 的编排功能, 同时 podman 也没有集群管理功能,如果需要管理集群, 需要第三方工具完成.\n所以 podman 定位也不是编排和集群管理工具, 紧紧是一个 pod 和容器的管理工具. 所以不是一个级别的东西, 这里不做太多的比较.\n和 docker 的区别 如果仅仅从 docker 和 podman 两个命令提供的功能来讲,它们功能交集很大, podman 官方甚至推荐 alias docker=podman 来过渡.\n docker 文档更齐全, podman 可以借用一下 docker 的文档 docker 生态更加完善, podman 一时半会赶不上,但是如果你只是去跑容器, 那这是一样的 docker 有 docker-compose, podman 早期没有对应工具,后面也出了 podman-compose, 但是这个功能是否必须? 值得考虑,因为 podman 支持 pod 管理. docker 有 machine , 让 windows 和 mac 支持 linux 容器, podman 也支持,而且已经比较完善. docker 有 docker-desktop , podman-desktop 目前还比较简单. docker 支持 rest api , podman 也支持 rest api, 这使得开发生态工具会比较简单. docker 有 swarm 支持集群部署, podman 没有对应工具, 不过支持 remote , 调用远程机器上的 podman service 执行对应的功能 , 这样能满足很多轻量化的场景. k8s 之前支持使用 docker-shim 和 docker 集成, 不过新版本也放弃这一层, 直接通过 CRI 调用 contained , podman 也不支持 CRI. 并且也没有什么计划. docker 商业/开源并行, podman 只有开源版本, 目前没有哪家公司提供商业支持(不清楚 redhat 有没有对应的服务,可能集成在订阅里面了).  为什么选 podman 上面讲了不少 docker 比 podman 有优势的方面, 这里开始讲 podman 的另外的东西, 这也是我选择 podman 主要原因.\n先罗列一下 podman 适合的场景\n 没有很强的集群管理需求(或者说,已经有 overlay network 方案, podman 也是适用的) 仅仅为了容器化一些应用 团队内部轻量级使用,比如 ci/cd , 开发,测试环境等. 喜欢命令行或者脚本运维 感兴趣 podman 的生态建设(坑)  那么 podman 比 docker 好的方面有哪些呢?\n 更加 rootless , 尽管 docker 也可以 rootless, 但是 podman 设计之初就开始支持 没有 daemon , 这使得 podman 在结合 namespace 和 cgroup 一起使用会更加灵活 pod , 和 k8s 基本一样的 pod , 一样支持 infra 容器. 这使得一些简单的容器编排 工作, podman 也可以简单实现. systemd service 集成, 由于没有 deamon , podman 通过 generate 子命令, 可以生成 systemd service 配置, 来管理容器和 pod 的作为服务启动. k8s 关联, podman 可以生成 kubectl 的 yaml 配置文件, 也通过 podman play kube 来运行 k8s 的配置, 也可以作为 k8s 的一个过渡吧, 而且 podman 也没有去实现 CRI 的计划, 这应该也是官方的态度, 不会参和到 k8s 生态中, 保持自己的轻量化工具的定位吧. remote , podman 通过 ssh 隧道或者 tcp 端口, 可以连接到远程机器上的 podman service, 从而实现远程机器上的容器和 pod 管理.  所以 podman 提供了一些轻量化而又灵活的功能特性,满足容器化,以及小批量服务器的场景.\n最后聊聊 podman 所在的 https://github.com/containers 组织 查看这个组织的仓库可以看到,他们真的是在做容器工具, 而且写了很多轮子, 包括 buildah 和 skopeo 这两个工具,与 podman 一起被称为下一代容器工具.\nrunc 是一个有名的 low-level OCI rumtime, 他们就开发了一个 crun . podman 早期版本使用 runc, 最新的版本已经使用 crun 了.\n众所周知, golang 是容器生态的主要语言, podman 也是 go 写的,但是在 podman 4 的版本中, podman 增加了非 CNI 的网络栈支持, 这几个工具是 netavark 和 aardvark-dns, 这两个工具是 rust 写的, 而且还有 youki 这个 rust 写的 low-level OCI runtime, 不知道将来某一天 podman 会不会默认使用 youki , 还有好几个 rust 写的容器技术相关的应用和库, 这是要与 golang 分天下的节奏.\n如果你也对 podman 以及其生态感兴趣, 关注我吧, 我会给你带来 podman 最新的动态以及实践方案.\n我的技术 Blog:https://liangdi.me\n","date":"2022-04-27T16:30:35+08:00","image":"https://liangdi.me/p/what-is-podman-and-different-from-kubernetes-and-docker/assets/podman-vs-docker_hub3205ed3c893c1f053112545244d1e4e_65326_120x120_fill_q75_box_smart1.jpg","permalink":"https://liangdi.me/p/what-is-podman-and-different-from-kubernetes-and-docker/","title":"选择 podman 的理由, 以及它和 Kubernetes , Docker 的区别"},{"content":"概述 使用 rust 也挺长时间了,但是一直是内部小打小闹,没有往客户那边推, 这次和客户商量好,拿一个很小的 java spring boot 项目开刀.\n这个项目小到 tiny 级别, 主要功能是: 请求一个服务, 对数据进行业务逻辑处理后, 使用 freemarker 渲染呈现给终端用户, rest api 也就 10 多个.\n迁移准备 首先,业务逻辑使用 rust 实现,肯定是没有大问题, 关键在于一些中间件和第三方库是否有替代,这样可以让运维或者交付更加平滑一点, 由于项目比较简单,第三方库也很通用,基本在 rust 这边也有对等的选择,所以本次迁移也将会简单很多.\n迁移说明 库和中间件迁移    库/中间件 Rust 版本 Java 版本 备注     Web Framework actix-web 4 Spring Boot 2.6.x    http cleint reqwest jdk 11 HttpClient    json serde_json gson    template tera freemarker    logging log4rs spring boot logging    assets embedded rust-embed spring boot static    配置 dotenv spring boot 项目小, 配置需求不高, dotenv 够用    有没有坑?  由于项目实在不复杂, 过程中也没有遇到特别的问题, rust 的库也能正常工作, 从代码的角度很多时候比 java 简洁, 当然集成没有 spring boot 那么简单, 比如配置的自动读取赋值, 模板需要手动集成等等. spring boot 的 rest request 配置, 对应在 actix-web 中也是很简单,使用 #[get], #[post] 等宏实现, 请求内容的解构也一样完善, 迁移过程中没有遇到什么问题. 模板方面, tera 是 Jinja2/Django like 的所以,使用起来也没有什么障碍. 战胜 rust 编译器后,程序运行,完成测试没有遇到什么 bug !  迁移后的变化 程序尺寸  spring boot jar 大小 20MB, 即使是 spring-native 打包也要 60 多 mb, 并且 spring-native 打包的程序没法正常运行,因为 spring-native 还没有 GA ,所以也没有去深究. rust 的程序使用 x86_64-unknown-linux-musl target release 静态编译打包(默认配置,无其他优化), 程序 strip 后是 9.3MB , 相比 jar 也小了一半, 还没考虑 jdk. 容器化, 这点 rust 的优势就体现出来了, 使用 FROM scratch 打包出来的镜像大小是 9.75MB , 相比 spring boot 项目, 基本的 openjdk:17-alpine 就有 320 多 MB 加上项目程序,也要 340 多 MB 了.  性能  肉眼可见的启动块了, 模板渲染也快了 程序瓶颈在于远程的服务,所以当前程序性能测试并不一定可靠,所以并没有去做特别的测试 后续迁移更多项目后,再进行一次性能测试比较  思考  如果项目不复杂, java 迁移到 rust 还是不算复杂的. 容器化的收益是不小的,不管是启动速度还是镜像大小. 后面考虑将微服务化的 java 项目选择合适的项目再进行 rust 迁移.  ","date":"2022-04-26T11:06:35+08:00","image":"https://liangdi.me/p/a-tiny-app-migrate-from-java-to-rust/assets/java-rust_hu1a0eedb3cb55262de642044ece3234a1_193060_120x120_fill_box_smart1_3.png","permalink":"https://liangdi.me/p/a-tiny-app-migrate-from-java-to-rust/","title":"记录一次 java 小项目的 rust 迁移过程"},{"content":"何为云原生  云原生一词可谓是大红大紫, 老板见面不说一下都觉得落伍了,技术人员更是要与时俱进,学习这一系列的新技术\n 先看看 CNCF 对云原生的最新定义,注意云原生的定义一直是演进的,随着新技术,新架构的发展,定义也会变化.\n 云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式API。\n  这些技术能够构建容错性好、易于管理和便于观察的松耦合系统。结合可靠的自动化手段，云原生技术使工程师能够轻松地对系统作出频繁和可预测的重大变更。\n 以上这两段话来自 CNCF 的云原生定义.\n简单的说就是用各种技术实现了大多数人梦寐以求的理想系统方案!\n但是,如果一个传统技术栈的团队,要向云原生迁移,代价会是多大呢? 这是个值得思考的问题.\nCNCF 有两个子站点 https://glossary.cncf.io/ 和 https://landscape.cncf.io/\n这两个站点可以大致了解云原生涉及到新概念以及生态图谱, 如此多的概念和繁杂的生态,对于传统技术团队来说将会带来额外的心智负担以及新的挑战.\n渐进式云原生 因此针对我们小团队以及小部门,我提出了渐进式云原生 和 轻量化云原生 的概念,以便云原生落地.\n渐进式云原生 是指自下往上,分阶段完成云原生迁移和落地. 这里大概会包含 容器化, 微服务化 , DevOps ,CI/DI 等方面向云端迁移, 而且不强调顺序, 实际的顺序大多数根团队的技术栈相关.\n所以这系列应该不会出现一来就叫你部署一套 k8s 集群, 可能到最后也不会,而是取决于你自己的选择.\n这一系列就是一次渐进式云原生的实践,废话一大推,我们进入正题\n使用 podman 容器化你的应用 第一篇是使用 podman 容器化你的应用 , 我认为容器化是迈向云原生过程中最简单的部分, 技术也成熟,风险不大. 这里为什么选择 podman ,详谈的话,需要再开一篇文章.\n实践目标 将一个传统的项目 CentOS -\u0026gt; Nginx -\u0026gt; (Spring Boot, MySQL, Redis) 容器化\n原项目是一个不算复杂的 Spring Boot 应用, 由于 Java 没法热更新, 所以使用 Nginx 反向代理了两套 Spring Boot 应用(两套应用可以同时运行也可以只运行一套), 关键时刻可实现用户无感知更新.\n两套 Spring Boot 应用监听不同端口, 使用 Systemd 作为系统服务配置, 上传新 jar 包后, 重启一个项目后, 再重启另外一个项目, 可以通过简单脚本实现.\n前端静态页面\n拓扑图如下: 实践过程 系统和 podman 的版本选择 原先部署在 CentOS 8 上, 这次容器化对 HOST 系统就没有特别的要求了, 所以选择了 Fedora Server, 三个原因: 一, 本人工作电脑使用 Fedora . 二, 容器技术依赖于 Linux 内核的 cgroup 和 namespace 技术,新内核会比老内核有优势, 虽然 Fedora 内核很新, 但是我相信 Linux 内核的稳定性. 三, CentOS 已经不再维护.\nPodman 我选择了最新的 4.0.x, 它和 3.x 版本不兼容功能, 但是使用上不会有差别, 主要是网络功能默认使用了 netavark 和 aardvark-dns ,没有使用 cni, 这两个工具是用 rust 编写的, 这也是我去尝试的主要原因之一\n容器使用选择 rootfull 还是 rootless , 我这里选择 root 运行, rootless 其实问题也不大,我测试除了没法 ping, 80/443端口等问题外, 还有一个不算特别大的问题就是, 容器创建好后无法再加入网络,需要创建的时候指定网络, root 情况下没问题.\n禁用 selinux  安装 podman fedora 中安装 podman 很简单\n1 2  sudo dnf copr enable rhcontainerbot/podman4 sudo dnf install podman   如果是安装 3.x 的版本, 还需要额外安装 podman-plugins 包,以实现 cni 网络的 dns 服务功能\n1 2  sudo dnf install podman sudo dnf install podman-plugins   在使用上版本 4 和版本 3 没有直接区别\n新的拓扑架构 还没有完全想好 nginx 这个前端代理以及前端静态页面是否要容器化,所以这里先保留之前的部署方案,拓扑图如下: 创建容器网络和基础容器 根据新的拓扑设计, Spring Boot 应用, MySQL , Redis 将会是以独立容器存在,所以需要创建一个网络将他们链接.\n1 2 3 4 5 6  # 创建名为 prod 的容器网络 podman network create prod # 查看网络 podman network ls # 之后创建或者运行容器的时候使用 --net prod 即可将容器加入到这个网络中   redis 容器\n使用以下命令创建 redis 容器\n1  podman run -d --name redis --net prod redis   podman 支持多镜像服务器 , 所以如果不指定镜像服务器, 会让你选择, 一般选择 dokcer.io 的即可\n注意: 上面使用 \u0026ndash;net prod 将 redis 容器加入到网络中, 同时指定了名字 redis , 这样网络中的主机名会是 redis , 也可以使用 \u0026ndash;hostname 参数\n注意2: 上面的命令没有使用 -p 6379:6379 将 redis 端口暴露出来,因为我们的 Spring Boot 应用也会加入到 prod 网络中,内网是可以访问的,所以不需要暴露出来.\n可以使用以下命令测试 redis 容器\n1 2 3 4  podman exec -it redis redis-cli PING # 正常返回 PONG # 也可以进入容器 bash 测试 podman exec -it redis bash   mysql 容器\n1 2 3 4 5  podman run \\  -e MYSQL_ROOT_PASSWORD=12345678 \\  --net prod \\  -v /opt/deploy/mysql/data:/var/lib/mysql \\  --name mysql -d mysql:8   -e MYSQL_ROOT_PASSWORD=12345678 指定了容器中 mysql root 用户的密码\n-v /opt/deploy/mysql/data:/var/lib/mysql 将 host 机器 /opt/\u0026hellip;./data 目录挂载到容器中 /var/lib/mysql 中, 这样 mysql 数据才能正常保存,如果缺少这个, 容器重启后, 数据将会被重置.\n更多配置查看 https://hub.docker.com/_/mysql\n创建 Spring Boot 容器 应用容器比较特殊,因为是内部应用, 也没法将应用发布到公共镜像上, 正常的流程是将应用打包,发布到私有镜像服务器中,再在 podman 中使用, 这里先跳过这一步,不然内容太多了!!!\n我这里创建了一个公共镜像 https://github.com/Liangdi/spring-boot-launcher\n这个镜像主要就是 jdk 环境,可以通过配置端口和 jar 名称,运行指定的 Spring Boot 项目\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  # 创建端口为 9090 的 Spring Boot 应用 PORT=9090 podman run -d --name sprin-boot-app-$PORT \\ -v /opt/deploy/app/:/deploy \\ -e APP_PORT=$PORT \\ --net prod \\ -p $PORT:$PORT \\ docker.io/liangdi/spring-boot-launcher # 创建端口为 9091 的 Spring Boot 应用 PORT=9091 podman run -d --name sprin-boot-app-$PORT \\ -v /opt/deploy/app/:/deploy \\ -e APP_PORT=$PORT \\ --net prod \\ -p $PORT:$PORT \\ docker.io/liangdi/spring-boot-launcher   Spring Boot 应用容器化后,只需要将原先 mysql , redis 的链接配置修改一下即可, 原先是使用 127.0.0.1, 容器化后,改为容器主机名 mysql 和 redis 即可.\nNginx 反向代理和前端静态文件方面,没有去改动.\n到此, 此次 Spring Boot 应用基本容器化完成, 后续就是要将应用微服务化了. 伴随着渐进式云原生,可能在运维,测试,客户交付方面也会有所改变.\n创建 systemd 服务 使用 podman generate systemd 创建 sytemd service, 具体看文档 https://docs.podman.io/en/latest/markdown/podman-generate-systemd.1.html , 这里不再说明.\n容器化总结  基本的容器化,程序开发上不需要有改变, 只是简单修改 prod 的配置文件 运维人员工作流程基本没变 podman 基本兼容 docker 命令,所以有 docker 经验将很容易上手. 静态页面需不需要容器化,值的思考,如果是大流量应用, 静态页面肯定是 CDN , 如果是小应用, 那么多开一个容器多起一个静态服务器是否又是浪费? 我这次没有将静态页面容器化. 后续有新想法后再迭代 podman 中还有 pod 管理功能,这也是我选择 podman 的原因之一,这方面将会在下次容器有化中使用. 这次交付产物使用 -v 路径的方式告知容器,后续可以使用命名 volume 替代.  ","date":"2022-04-23T16:59:14+08:00","permalink":"https://liangdi.me/p/progressive-cloud-native-with-podman/","title":"渐进式云原生实践: 使用 podman 容器化你的应用"}]