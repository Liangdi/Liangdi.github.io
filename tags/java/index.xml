<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on Liangdi&#39;s个人博客</title>
    <link>https://liangdi.me/tags/java/</link>
    <description>Recent content in Java on Liangdi&#39;s个人博客</description>
    <generator>Hugo</generator>
    <language>zh</language>
    <lastBuildDate>Tue, 26 Apr 2022 11:06:35 +0800</lastBuildDate>
    <atom:link href="https://liangdi.me/tags/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>记录一次 java 小项目的 rust 迁移过程</title>
      <link>https://liangdi.me/posts/a-tiny-app-migrate-from-java-to-rust/</link>
      <pubDate>Tue, 26 Apr 2022 11:06:35 +0800</pubDate>
      <guid>https://liangdi.me/posts/a-tiny-app-migrate-from-java-to-rust/</guid>
      <description>&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;&#xA;&lt;p&gt;使用 rust 也挺长时间了,但是一直是内部小打小闹,没有往客户那边推, 这次和客户商量好,拿一个很小的 java spring boot 项目开刀.&lt;/p&gt;&#xA;&lt;p&gt;这个项目小到 tiny 级别, 主要功能是: 请求一个服务, 对数据进行业务逻辑处理后, 使用 freemarker 渲染呈现给终端用户, rest api 也就 10 多个.&lt;/p&gt;&#xA;&lt;h2 id=&#34;迁移准备&#34;&gt;迁移准备&lt;/h2&gt;&#xA;&lt;p&gt;首先,业务逻辑使用 rust 实现,肯定是没有大问题, 关键在于一些中间件和第三方库是否有替代,这样可以让运维或者交付更加平滑一点, 由于项目比较简单,第三方库也很通用,基本在 rust 这边也有对等的选择,所以本次迁移也将会简单很多.&lt;/p&gt;&#xA;&lt;h2 id=&#34;迁移说明&#34;&gt;迁移说明&lt;/h2&gt;&#xA;&lt;h3 id=&#34;库和中间件迁移&#34;&gt;库和中间件迁移&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;库/中间件&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;Rust 版本&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;Java 版本&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;备注&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Web Framework&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;actix-web 4&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Spring Boot 2.6.x&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;http cleint&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;reqwest&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;jdk 11 HttpClient&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;json&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;serde_json&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;gson&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;template&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;tera&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;freemarker&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;logging&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;log4rs&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;spring boot logging&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;assets embedded&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;rust-embed&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;spring boot static&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;配置&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;dotenv&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;spring boot&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;项目小, 配置需求不高, dotenv 够用&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;有没有坑&#34;&gt;有没有坑?&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;由于项目实在不复杂, 过程中也没有遇到特别的问题, rust 的库也能正常工作, 从代码的角度很多时候比 java 简洁, 当然集成没有 spring boot 那么简单, 比如配置的自动读取赋值, 模板需要手动集成等等.&lt;/li&gt;&#xA;&lt;li&gt;spring boot 的 rest request 配置, 对应在 actix-web 中也是很简单,使用 #[get], #[post] 等宏实现, 请求内容的解构也一样完善, 迁移过程中没有遇到什么问题.&lt;/li&gt;&#xA;&lt;li&gt;模板方面, &lt;code&gt;tera&lt;/code&gt; 是 &lt;code&gt;Jinja2/Django&lt;/code&gt; like 的所以,使用起来也没有什么障碍.&lt;/li&gt;&#xA;&lt;li&gt;战胜 rust 编译器后,程序运行,完成测试没有遇到什么 bug !&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;迁移后的变化&#34;&gt;迁移后的变化&lt;/h2&gt;&#xA;&lt;h3 id=&#34;程序尺寸&#34;&gt;程序尺寸&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;spring boot jar 大小 20MB, 即使是 spring-native 打包也要 60 多 mb, 并且 spring-native 打包的程序没法正常运行,因为 spring-native 还没有 GA ,所以也没有去深究.&lt;/li&gt;&#xA;&lt;li&gt;rust 的程序使用 &lt;code&gt;x86_64-unknown-linux-musl&lt;/code&gt; target release 静态编译打包(默认配置,无其他优化), 程序 strip 后是 9.3MB , 相比 jar 也小了一半, 还没考虑 jdk.&lt;/li&gt;&#xA;&lt;li&gt;容器化, 这点 rust 的优势就体现出来了, 使用 &lt;code&gt;FROM scratch&lt;/code&gt; 打包出来的镜像大小是 9.75MB , 相比 spring boot 项目, 基本的 openjdk:17-alpine 就有 320 多 MB 加上项目程序,也要 340 多 MB 了.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;性能&#34;&gt;性能&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;肉眼可见的启动块了, 模板渲染也快了&lt;/li&gt;&#xA;&lt;li&gt;程序瓶颈在于远程的服务,所以当前程序性能测试并不一定可靠,所以并没有去做特别的测试&lt;/li&gt;&#xA;&lt;li&gt;后续迁移更多项目后,再进行一次性能测试比较&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;思考&#34;&gt;思考&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果项目不复杂, java 迁移到 rust 还是不算复杂的.&lt;/li&gt;&#xA;&lt;li&gt;容器化的收益是不小的,不管是启动速度还是镜像大小.&lt;/li&gt;&#xA;&lt;li&gt;后面考虑将微服务化的 java 项目选择合适的项目再进行 rust 迁移.&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
  </channel>
</rss>
